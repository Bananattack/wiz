include '../gameboy.wiz'
include 'layout.wiz'
include 'ram.wiz'
include 'boot.wiz'
include 'joy.wiz'
include 'video.wiz'
include 'player.wiz'

// Fills a range in memory with a specified byte value.
// Dirty: bc, hl
// Arguments:
//      hl = destination
//      a = value
//      bc = count
def memset: do
    c++
    b++
    goto start
def repeat:
    [hl++] = a
def start:
    c--; goto repeat when ~zero
    b--; goto repeat when ~zero
    return
end

inline memset_inline: do
    c++
    b++
    goto start
def repeat:
    [hl++] = a
def start:
    c--; goto repeat when ~zero
    b--; goto repeat when ~zero
end

package hardware
    def detect: do
        hl = hardware.type
        [hl] = hardware.GB
        compare a to 0x11
        if == then
            [hl] = hardware.GBC
            compare b@0
            if ~zero then
                [hl] = hardware.GBA
            end
        end
        return
    end
end

def main: do
    interrupt = 0
    hl = stack.top
    sp = hl
    
    call hardware.detect
    call joy.init
    call video.init
    call player.init

    call video.disable
    [gb.scroll.y] = 0 via a
    [gb.window.y] = 0 via a
    [gb.mono.palette.bg] = 0b11100100 via a

    hl = gb.ram.tile
    a = 0b11111111
    bc = 16
    call memset
    a = 0b10101010
    bc = 16
    call memset
    a = 0b10001000
    bc = 16
    call memset 
    a = 0b00000000
    bc = 16
    call memset
    hl = gb.ram.map + 32
    a = 0x03
    bc = 1024 - 64
    call memset
    hl = gb.ram.map
    a = 0x00
    bc = 20
    call memset
    hl = gb.ram.map + (32 * 17)
    bc = 20
    call memset
    hl = gb.ram.map + 32
    bc = 32
    unroll * 16: do [hl] = a; hl = hl + bc end
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    hl = gb.ram.map + 32 + 19
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc
    [hl] = a; hl = hl + bc

    [gb.lcd.ctrl] = gb.lcd.CTRL_ON | gb.lcd.CTRL_TILESET2 | gb.lcd.CTRL_BG_ON via a
    [gb.lcd.stat] = gb.lcd.STAT_SCANLINE_ENABLE via a
    [gb.interrupt.enable] = gb.interrupt.VBLANK | gb.interrupt.STAT via a
    interrupt = 1
    loop
        call joy.check
        call player.update
        call video.flush
    end
end

def draw: do
    call video.acknowledge
    hl = pop
    de = pop
    bc = pop
    af = pop
    resume
end

def stat: do
    loop
        a = [gb.lcd.stat] & gb.lcd.STAT_MODE_MASK
        compare a to gb.lcd.STAT_MODE_HBLANK
    until == end
    hl = pop
    de = pop
    bc = pop
    af = pop
    resume
end

def stub: do
    hl = pop
    de = pop
    bc = pop
    af = pop
    resume
end
let timer = stub
let serial = stub
let joypad = stub
