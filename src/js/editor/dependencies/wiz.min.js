(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};

    wiz.VersionText = '0.1 (js)';

    function scannerTest(scanner) {
        do {
            var token = scanner.next();
            var text = scanner.consumeLastText();
            wiz.compile.log(token + ' ' + wiz.parse.getVerboseTokenName(token, text));
        } while(token != wiz.parse.Token.EndOfFile);
    }

    function run(source, filename, platform) {
        var scanner = wiz.parse.Scanner(wiz.fs.MemoryFile(source), filename);
        var parser = wiz.parse.Parser(scanner);
        var program;
        switch(platform) {
            case "gb":
                program = wiz.compile.Program(wiz.cpu.gameboy.GameboyPlatform());
                break;
            case "6502":
                program = wiz.compile.Program(wiz.cpu.mos6502.Mos6502Platform());
                break;
            default:
                throw new Error("unsupported platform " + platform);
        }

        wiz.compile.log(">> Building...");
        var block = parser.parse();

        wiz.compile.build(program, block);
      
        wiz.compile.log(">> Writing ROM...");
        var buffer = program.save();

        //wiz.compile.log(">> Wrote to '" + output + "'.");
        wiz.compile.notice("Done.");
        return buffer;
    }

    wiz.build = function(source, filename, platform) {
        wiz.compile.clearErrors();
        wiz.compile.clearLog();
        wiz.fs.reset();
        wiz.compile.notice("version " + wiz.VersionText);

        try {
            return run(source, filename, platform);
        } catch(e) {
            if(e instanceof wiz.compile.CompileExit) {
                // Exit request, handle silently.
            } else {
                wiz.compile.log(e.stack);
                throw e;
            }
        }
    }
})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.ast = typeof(wiz.ast) !== 'undefined' ? wiz.ast : {};

    wiz.ast.Expression = {};
    wiz.ast.Expression.Max = 65535;

    wiz.ast.Number = function(numberType, value, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Number';
        that.numberType = numberType;
        that.value = value;
        return that;
    }

    wiz.ast.Attribute = function(pieces, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Attribute';
        that.pieces = pieces;
        that.fullName = pieces.join('.');
        return that;
    }

    wiz.ast.String = function(value, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'String';
        that.value = value;
        return that;
    }

    wiz.ast.Pop = function(location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Pop';
        return that;
    }

    wiz.ast.Infix = function(infixTypes, operands, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Infix';
        that.nodeChildren = ['operands'];
        that.types = infixTypes;
        that.operands = operands;
        return that;
    }

    wiz.ast.Prefix = function(prefixType, operand, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Prefix';
        that.nodeChildren = ['operand'];
        that.type = prefixType;
        that.operand = operand;
        return that;
    }

    wiz.ast.Postfix = function(postfixType, operand, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Postfix';
        that.nodeChildren = ['operand'];
        that.type = postfixType;
        that.operand = operand;
        return that;
    }
})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.ast = typeof(wiz.ast) !== 'undefined' ? wiz.ast : {};

    wiz.ast.check = function(nodeType, node) {
        if(typeof(node) === 'object' && node && node.nodeType == nodeType) {
            return node;
        }
        return null;
    }

    var nodeId = 0;
    wiz.ast.Node = function(location) {
        var that = {};
        that.nodeId = '$node' + (nodeId++) + '$';
        that.nodeType = 'Node';
        that.nodeChildren = null;
        that.location = location.copy();
        return that;
    }
})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.ast = typeof(wiz.ast) !== 'undefined' ? wiz.ast : {};

    wiz.ast.Assignment = function(dest, intermediary, src, postfixType, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Assignment';
        that.nodeChildren = ['dest', 'intermediary', 'src'];
        that.dest = dest;
        that.intermediary = intermediary;
        that.src = src;
        that.postfix = postfixType;
        return that;
    }

    wiz.ast.BankDecl = function(names, type, size, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'BankDecl';
        that.nodeChildren = ['size'];
        for(var i = 0, len = names.length; i < len; i++) {
            names[i] = "bank " + names[i];
        }
        that.names = names;
        that.type = type;
        that.size = size;
        return that;
    }

    wiz.ast.Block = function(name, statements, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Block';
        that.nodeChildren = ['statements'];
        that.name = name;
        that.statements = statements;
        return that;
    }

    wiz.ast.BuiltinDecl = function(name) {
        var that = wiz.ast.Node(wiz.compile.Location("<builtin>"));
        that.nodeType = 'BuiltinDecl';
        that.name = name;
        return that;
    }

    wiz.ast.Comparison = function(left, right, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Comparison';
        that.nodeChildren = ['left', 'right'];
        that.left = left;
        that.right = right;
        return that;
    }

    wiz.ast.Conditional = function(trigger, far, prelude, action, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Conditional';
        that.nodeChildren = ['action', 'alternative', 'block'];
        that.trigger = trigger;
        that.far = far;
        that.prelude = prelude;
        that.action = action;
        that.alternative = null;

        that.block = null;
        that.expand = function() {
            var location = that.location;
            var trigger = that.trigger;
            var far = that.far;
            var prelude = that.prelude;
            var action = that.action;
            var alternative = that.alternative;

            if(!alternative) {
                that.block = wiz.ast.Block(null, [
                    // prelude
                    prelude,
                    // goto $end when ~trigger
                    wiz.ast.Jump(wiz.parse.Keyword.Goto, far,
                        wiz.ast.Attribute(["$end"], location),
                        wiz.ast.JumpCondition(true, trigger, location), location
                    ),
                    // action
                    action,
                    // def $end:
                    wiz.ast.LabelDecl("$end", location)
                ], location);
            } else {
                that.block = wiz.ast.Block(null, [
                    // prelude
                    prelude,
                    // goto $else when ~trigger
                    wiz.ast.Jump(wiz.parse.Keyword.Goto, far,
                        wiz.ast.Attribute(["$else"], location),
                        wiz.ast.JumpCondition(true, trigger, location), location
                    ),
                    // action
                    action,
                    // goto $end
                    wiz.ast.Jump(wiz.parse.Keyword.Goto, far,
                        wiz.ast.Attribute(["$end"], location),
                        null, location
                    ),
                    // def $else:
                    wiz.ast.LabelDecl("$else", location),
                    //   alternative
                    alternative,
                    // def $end:
                    wiz.ast.LabelDecl("$end", location)
                ], location);
            }

            // Now that we've exanded, remove original statements
            that.action = null;
            that.alternative = null;
        }

        return that;
    }

    wiz.ast.Data = function(storage, items, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Data';
        that.nodeChildren = ['storage', 'items'];
        that.storage = storage;
        that.items = items;
        return that;
    }

    wiz.ast.Embed = function(filename, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Embed';
        that.filename = filename;
        that.data = [];
        return that;
    }

    wiz.ast.FuncDecl = function(type, name, block, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'FuncDecl';
        that.nodeChildren = ['block', 'statements'];        
        that.inlined = false;
        that.type = type;
        that.name = name;
        that.inner = block;
        that.block = block;
        that.statements = [];

        that.expand = function() {
            if(!that.inlined) {
                // def name:
                that.statements.push(wiz.ast.LabelDecl(that.name, that.location));
                //     block
                that.statements.push(that.block);
                //     return
                switch(type) {
                    case wiz.parse.Keyword.Func:
                        that.statements.push(
                            wiz.ast.Jump(wiz.parse.Keyword.Return, false, null, null, that.location)
                        );
                        break;
                    case wiz.parse.Keyword.Task:
                        that.statements.push(
                            wiz.ast.Jump(wiz.parse.Keyword.Resume, false, null, null, that.location)
                        );
                        break;
                    default:
                        throw new Error('unhandled function type');
                }
            }
            that.block = null;
        }

        return that;
    }

    wiz.ast.Jump = function(type, far, destination, condition, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Jump';
        that.nodeChildren = ['destination', 'condition', 'inlining'];
        that.type = type;
        that.far = far;
        that.destination = destination;
        that.condition = condition;
        that.inlining = null;

        that.expand = function(block) {
            switch(type) {
                case wiz.parse.Keyword.Continue:
                    that.type = wiz.parse.Keyword.Goto;
                    that.destination = wiz.ast.Attribute(["$loop"], that.location);
                    break;
                case wiz.parse.Keyword.While:
                    that.type = wiz.parse.Keyword.Goto;
                    that.destination = wiz.ast.Attribute(["$end"], that.location);
                    that.condition = wiz.ast.JumpCondition(true, that.condition, that.condition.location);
                    break;
                case wiz.parse.Keyword.Until:
                case wiz.parse.Keyword.Break:
                    that.type = wiz.parse.Keyword.Goto;
                    that.destination = wiz.ast.Attribute(["$end"], that.location);
                    break;
                case wiz.parse.Keyword.Inline:
                    that.inlining = block;
                    break;
                default:
                    throw new Error('unhandled jump type');
            }
        }

        return that;
    }

    wiz.ast.JumpCondition = function(negated, condition, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'JumpCondition';
        that.nodeChildren = ['attr'];
        that.attr = null;
        that.branch = null;
        if(wiz.ast.check('JumpCondition', condition)) {
            that.negated = negated ? !condition._negated : condition.negated;
            that.attr = condition.attr;
            that.branch = condition.branch;
        } else if(wiz.ast.check('Attribute', condition)) {
            that.negated = negated;
            that.attr = condition;
        } else if(condition && wiz.parse.Branch[condition]) {
            that.negated = negated;
            that.branch = condition;
        } else {
            throw new Error("condition must be wiz.ast.JumpCondition, wiz.ast.Attribute, or a wiz.parse.Branch");
        }
        return that;
    }

    wiz.ast.LabelDecl = function(name, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'LabelDecl';
        that.name = name;
        return that;
    }

    wiz.ast.LetDecl = function(name, value, offset, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'LetDecl';
        that.nodeChildren = ['value'];
        that.name = name;
        that.value = value;
        that.offset = offset;
        return that;
    }

    wiz.ast.Loop = function(block, far, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Loop';
        that.nodeChildren = ['block'];
        that.block = block;
        that.far = far;

        that.expand = function() {
            var block = that.block;
            var far = that.far;
            var tailConditional = false;
            var location = that.location;
            if(block.statements.length > 0) {
                // 'while' or 'until' as last statement of loop?
                var tail = wiz.ast.check('Jump', block.statements[block.statements.length - 1]);
                if(tail) {
                    switch(tail.type) {
                        case wiz.parse.Keyword.While:
                            // Tail 'while cond' -> 'continue when cond'.
                            tailConditional = true;
                            var jump = wiz.ast.Jump(wiz.parse.Keyword.Continue, far || tail.far, null,
                                tail.condition, tail.location
                            );
                            block.statements[block.statements.length - 1] = jump;
                            break;
                        case wiz.parse.Keyword.Until:
                            // Tail 'until cond' -> 'continue when ~cond'.
                            tailConditional = true;
                            var jump = wiz.ast.Jump(wiz.parse.Keyword.Continue, far || tail.far, null,
                                wiz.ast.JumpCondition(true, tail.condition, tail.location), tail.location
                            );
                            block.statements[block.statements.length - 1] = jump;
                            break;
                        default:
                    }
                }
            }

            // def $loop:
            //   block
            //   goto $loop // (this line is removed if there is a while/until as last statement.
            // def $end:
            var code = [];
            code.push(wiz.ast.LabelDecl("$loop", location));
            code.push(block);
            if(!tailConditional) {
                // Remove unconditional jump,
                code.push(wiz.ast.Jump(wiz.parse.Keyword.Goto, far,
                    wiz.ast.Attribute(["$loop"], location),
                    null, location
                ));
            }
            code.push(wiz.ast.LabelDecl("$end", location));
            that.block = wiz.ast.Block(null, code, location);
        }
        return that;
    }

    wiz.ast.Push = function(src, intermediary, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Push';
        that.nodeChildren = ['src', 'intermediary'];
        that.src = src;
        that.intermediary = intermediary;
        return that;
    }

    wiz.ast.Relocation = function(name, dest, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Relocation';
        that.nodeChildren = ['dest'];
        that.name = name;
        that.mangledName = 'bank ' + name;
        that.dest = dest;
        return that;
    }

    wiz.ast.Storage = function(type, size, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Storage';
        that.nodeChildren = ['size'];
        that.type = type;
        that.size = size;
        return that;
    }

    wiz.ast.Unroll = function(repetitions, block, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'Unroll';
        that.nodeChildren = ['block'];
        that.repetitions = repetitions;
        that.block = block;

        that.expand = function(times) {
            var code = [];
            for(var i = 0; i < times; i++) {
                code.push(wiz.ast.Block(null, that.block.statements, that.location));
            }
            that.block = wiz.ast.Block(null, code, that.location);
        }
        
        return that;
    }

    wiz.ast.VarDecl = function(names, storage, location) {
        var that = wiz.ast.Node(location);
        that.nodeType = 'VarDecl';
        that.nodeChildren = ['storage'];
        that.names = names;
        that.storage = storage;
        return that;
    }
})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.cpu = typeof(wiz.cpu) !== 'undefined' ? wiz.cpu : {};

    wiz.cpu.AbstractPlatform = function() {
        var that = {};
        that.builtins = function() { throw new Error('not implemented'); }
        that.generatePush = function(program, stmt) { throw new Error('not implemented'); }
        that.generateJump = function(program, stmt) { throw new Error('not implemented'); }
        that.generateComparison = function(program, stmt) { throw new Error('not implemented'); }
        that.generateAssignment = function(program, stmt) { throw new Error('not implemented'); }
        that.patch = function(buffer) { throw new Error('not implemented'); }
        return that;
    }
})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.cpu = typeof(wiz.cpu) !== 'undefined' ? wiz.cpu : {};
    wiz.cpu.gameboy = typeof(wiz.cpu.gameboy) !== 'undefined' ? wiz.cpu.gameboy : {};

    var at = 0;
    wiz.cpu.gameboy.ArgumentType = {
        None: '$at' + (at++),
        Immediate: '$at' + (at++),
        Indirection: '$at' + (at++),
        IndirectionInc: '$at' + (at++),
        IndirectionDec: '$at' + (at++),
        PositiveIndex: '$at' + (at++),
        NegativeIndex: '$at' + (at++),
        BitIndex: '$at' + (at++),
        Not: '$at' + (at++),
        Negated: '$at' + (at++),
        Swap: '$at' + (at++),
        Pop: '$at' + (at++),
        A: '$at' + (at++),
        B: '$at' + (at++),
        C: '$at' + (at++),
        D: '$at' + (at++),
        E: '$at' + (at++),
        F: '$at' + (at++),
        H: '$at' + (at++),
        L: '$at' + (at++),
        AF: '$at' + (at++),
        BC: '$at' + (at++),
        DE: '$at' + (at++),
        HL: '$at' + (at++),
        SP: '$at' + (at++),
        Carry: '$at' + (at++),
        Zero: '$at' + (at++),
        Interrupt: '$at' + (at++),
    }

    var ArgumentType = wiz.cpu.gameboy.ArgumentType;

    function wrap(s, quoted) {
        return quoted ? "'" + s + "'" : s;
    }

    // Argument(type[, immediate : wiz.ast.Expression][, base : Argument])
    wiz.cpu.gameboy.Argument = function(type, immediate, base) {
        var that = {};
        that.type = type;
        if(!base && immediate && typeof(immediate.nodeType) === 'undefined') {
            base = immediate;
            immediate = null;
        }
        that.immediate = immediate || null;
        that.base = base || null;

        that.toString = function(quoted) {
            switch(that.type) {
                case ArgumentType.None: return "???";
                case ArgumentType.Immediate: return "immediate";
                case ArgumentType.Indirection: return wrap("[" + base.toString(false) + "]", quoted);
                case ArgumentType.IndirectionInc: return wrap("[" + base.toString(false) + "++]", quoted);
                case ArgumentType.IndirectionDec: return wrap("[" + base.toString(false) + "--]", quoted);
                case ArgumentType.PositiveIndex: return wrap("[index:" + base.toString(false) + "]", quoted);
                case ArgumentType.NegativeIndex: return wrap("[-index:" + base.toString(false) + "]", quoted);
                case ArgumentType.BitIndex: return wrap(base.toString(false) + "@bit", quoted);
                case ArgumentType.Not: return wrap("~" + base.toString(false), quoted);
                case ArgumentType.Negated: return wrap("-" + base.toString(false), quoted);
                case ArgumentType.Swap: return wrap("<>" + base.toString(false), quoted);
                case ArgumentType.Pop: return wrap("pop", quoted);
                case ArgumentType.A: return wrap("a", quoted);
                case ArgumentType.B: return wrap("b", quoted);
                case ArgumentType.C: return wrap("c", quoted);
                case ArgumentType.D: return wrap("d", quoted);
                case ArgumentType.E: return wrap("e", quoted);
                case ArgumentType.F: return wrap("f", quoted);
                case ArgumentType.H: return wrap("h", quoted);
                case ArgumentType.L: return wrap("l", quoted);
                case ArgumentType.AF: return wrap("af", quoted);
                case ArgumentType.BC: return wrap("bc", quoted);
                case ArgumentType.DE: return wrap("de", quoted);
                case ArgumentType.HL: return wrap("hl", quoted);
                case ArgumentType.SP: return wrap("sp", quoted);
                case ArgumentType.Carry: return wrap("carry", quoted);
                case ArgumentType.Zero: return wrap("zero", quoted);
                case ArgumentType.Interrupt: return wrap("interrupt", quoted);
            }
        }

        that.getRegisterIndex = function() {
            switch(type) {
                case ArgumentType.B: return 0x0; break;
                case ArgumentType.C: return 0x1; break;
                case ArgumentType.D: return 0x2; break;
                case ArgumentType.E: return 0x3; break;
                case ArgumentType.H: return 0x4; break;
                case ArgumentType.L: return 0x5; break;
                case ArgumentType.Indirection:
                    if(base.type == ArgumentType.HL) {
                        return 0x6;
                    }
                    break;
                case ArgumentType.A: return 0x7; break;
                default:
            }
            throw new Error("argument is not register type");
        }

        that.getPairIndex = function() {
            switch(type) {
                case ArgumentType.BC: return 0x0; break;
                case ArgumentType.DE: return 0x1; break;
                case ArgumentType.HL: return 0x2; break;
                case ArgumentType.SP: return 0x3; break;
                case ArgumentType.AF: return 0x3; break;
                default:
            }
            throw new Error("argument is not pair type");
        }


        that.getPairLowIndex = function() {
            switch(type) {
                case ArgumentType.BC: return 0x1; break;
                case ArgumentType.DE: return 0x3; break;
                case ArgumentType.HL: return 0x5; break;
                default:
            }
            throw new Error("argument is not pair type");
        }

        that.getPairHighIndex = function() {
            switch(type) {
                case ArgumentType.BC: return 0x0; break;
                case ArgumentType.DE: return 0x2; break;
                case ArgumentType.HL: return 0x4; break;
                default:
            }
            throw new Error("argument is not pair type");
        }

        that.getFlagIndex = function(negated) {
            switch(type) {
                case ArgumentType.Zero: return negated ? 0x0 : 0x1; break;
                case ArgumentType.Carry: return negated ? 0x2 : 0x3; break;
                default: throw new Error("argument is not flag type");
            }
        }
        return that;
    }

    var Argument = wiz.cpu.gameboy.Argument;
    var ArgumentType = wiz.cpu.gameboy.ArgumentType;

    wiz.cpu.gameboy.Builtin = function(argumentType) {
        var that = wiz.sym.Definition(wiz.ast.BuiltinDecl());
        that.definitionType = 'Builtin';
        that.type = argumentType;
        return that;
    }

    wiz.cpu.gameboy.buildIndirection = function(program, root) {
        if(wiz.ast.check('Attribute', root)) {
            var def = wiz.compile.resolveAttribute(program, root);
            if(!def) {
                return null;
            }
            if(wiz.sym.check('Builtin', def)) {
                return Argument(ArgumentType.Indirection, Argument(def.type));
            }
        } else if(wiz.ast.check('Prefix', root)) {
            if(root.type == wiz.parse.Prefix.Indirection) {
                wiz.compile.error("double-indirection is not supported on the gameboy", root.location);
                return null;
            }
        }  else if(wiz.ast.check('Postfix', root)) {
            var argumentType;
            switch(root.type) {
                case wiz.parse.Postfix.Inc: argumentType = ArgumentType.IndirectionInc; break;
                case wiz.parse.Postfix.Dec: argumentType = ArgumentType.IndirectionDec; break;
            }
            var attr = root.operand;
            if(wiz.ast.check('Attribute', attr)) {
                var def = wiz.compile.resolveAttribute(program, attr);
                if(!def) {
                    return null;
                }
                if(wiz.sym.check('Builtin', def)) {
                    if(def.type == ArgumentType.HL) {
                        return Argument(argumentType, Argument(def.type));
                    }
                }
            }
            wiz.compile.error(
                "operator " + wiz.parse.getSimpleTokenName(root.type)
                + " on indirected operand is not supported (only '[hl"
                + wiz.parse.getSimpleTokenName(root.type) + "]' is valid)",
                root.location
            );
            return null;
        } else if(wiz.ast.check('Infix', root)) {
            var registerLeft;
            var registerRight;

            if(root.types[0] == wiz.parse.Infix.Colon) {
                var attr = root.operands[1];
                if(wiz.ast.check('Attribute', attr)) {
                    var def = wiz.compile.resolveAttribute(program, attr);
                    if(!def) {
                        return null;
                    }
                    if(wiz.sym.check('Builtin', def)) {
                        if(wiz.ast.check('Prefix', root.operands[0])) {
                            if(prefix.type == wiz.parse.Infix.Sub) {
                                return Argument(ArgumentType.NegativeIndex, root.operands[0].operand, Argument(def.type));
                            }
                        }
                        return Argument(ArgumentType.PositiveIndex, root.operands[0], Argument(def.type));
                    }
                }
                wiz.compile.error(
                    "index operator ':' must have register as a right-hand term",
                    root.location
                );
                return null;
            }
        } else if(wiz.ast.check('Pop', root)) {
            wiz.compile.error("'pop' is not allowed inside of indirection", root.location);
            return null;
        }
        return Argument(ArgumentType.Indirection, Argument(ArgumentType.Immediate, root));
    }

    wiz.cpu.gameboy.buildArgument = function(program, root) {
        var v;
        if(wiz.ast.check('Attribute', root)) {
            var def = wiz.compile.resolveAttribute(program, root);
            if(!def) {
                return null;
            }
            if(wiz.sym.check('Builtin', def)) {
                return Argument(def.type);
            }
        } else if(wiz.ast.check('Prefix', root)) {
            if(root.type == wiz.parse.Token.LBracket) {
                return wiz.cpu.gameboy.buildIndirection(program, root.operand);
            }
            if(root.type == wiz.parse.Token.Swap) {
                return Argument(ArgumentType.Swap, wiz.cpu.gameboy.buildArgument(program, root.operand));
            }
            if(root.type == wiz.parse.Token.Not) {
                return Argument(ArgumentType.Not, wiz.cpu.gameboy.buildArgument(program, root.operand));
            }
            if(root.type == wiz.parse.Token.Sub) {
                return Argument(ArgumentType.Negated, wiz.cpu.gameboy.buildArgument(program, root.operand));
            }
        } else if(wiz.ast.check('Infix', root)) {
            if(root.types[0] == wiz.parse.Token.At) {
                var attr = root.operands[0];
                if(wiz.ast.check('Attribute', attr)) {
                    var def = wiz.compile.resolveAttribute(program, attr);
                    if(!def) {
                        return null;
                    }
                    if(wiz.sym.check('Builtin', def)) {
                        return new Argument(ArgumentType.BitIndex, root.operands[1], new Argument(def.type));
                    }
                }
            }
        } else if(wiz.ast.check('Pop', root)) {
            return new Argument(ArgumentType.Pop);
        }
        return new Argument(ArgumentType.Immediate, root);
    }
})(this);/*jslint bitwise: true */
(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.cpu = typeof(wiz.cpu) !== 'undefined' ? wiz.cpu : {};
    wiz.cpu.gameboy = typeof(wiz.cpu.gameboy) !== 'undefined' ? wiz.cpu.gameboy : {};

wiz.cpu.gameboy.GameboyPlatform = function() {
    var that = wiz.cpu.AbstractPlatform();
    that.builtins = builtins;
    that.generatePush = generatePush;
    that.generateJump = generateJump;
    that.generateComparison = generateComparison;
    that.generateAssignment = generateAssignment;
    that.patch = patch;

    var Argument = wiz.cpu.gameboy.Argument;
    var ArgumentType = wiz.cpu.gameboy.ArgumentType;
    var buildIndirection = wiz.cpu.gameboy.buildIndirection;
    var buildArgument = wiz.cpu.gameboy.buildArgument;
    var error = wiz.compile.error;

    function builtins() {
        return {
            "a": wiz.cpu.gameboy.Builtin(ArgumentType.A),
            "b": wiz.cpu.gameboy.Builtin(ArgumentType.B),
            "c": wiz.cpu.gameboy.Builtin(ArgumentType.C),
            "d": wiz.cpu.gameboy.Builtin(ArgumentType.D),
            "e": wiz.cpu.gameboy.Builtin(ArgumentType.E),
            "f": wiz.cpu.gameboy.Builtin(ArgumentType.F),
            "h": wiz.cpu.gameboy.Builtin(ArgumentType.H),
            "l": wiz.cpu.gameboy.Builtin(ArgumentType.L),
            "af": wiz.cpu.gameboy.Builtin(ArgumentType.AF),
            "bc": wiz.cpu.gameboy.Builtin(ArgumentType.BC),
            "de": wiz.cpu.gameboy.Builtin(ArgumentType.DE),
            "hl": wiz.cpu.gameboy.Builtin(ArgumentType.HL),
            "sp": wiz.cpu.gameboy.Builtin(ArgumentType.SP),
            "carry": wiz.cpu.gameboy.Builtin(ArgumentType.Carry),
            "zero": wiz.cpu.gameboy.Builtin(ArgumentType.Zero),
            "interrupt": wiz.cpu.gameboy.Builtin(ArgumentType.Interrupt),
        };
    }

    function patch(buffer) {
        var headersum = 0;
        var globalsum = 0;
        for(var i = 0x134; i <= 0x14D; i++) {
            headersum = (headersum - buffer[i] - 1) & 0xFF;
        }
        buffer[0x14D] = headersum;
        for(var i = 0; i < buffer.length; i++) {
            if(i != 0x14E && i != 0x14F) {
                globalsum += buffer[i];
            }
        }
        buffer[0x14E] = (globalsum >> 8) & 0xFF;
        buffer[0x14F] = globalsum & 0xFF;
    }

    function generatePush(program, stmt) {
        var argument;
        var code = [];
        if(stmt.intermediary) {
            argument = buildArgument(program, stmt.intermediary);
            // 'push x via y' -> 'y = x; push y'
            code.push.apply(code, generateCalculatedAssignment(program, stmt, argument, stmt.src));
        } else {
            argument = buildArgument(program, stmt.src);
        }
        switch(argument.type) {
            case ArgumentType.AF: return code.push(0xF5), code;
            case ArgumentType.BC: return code.push(0xC5), code;
            case ArgumentType.DE: return code.push(0xD5), code;
            case ArgumentType.HL: return code.push(0xE5), code;
            default:
                error("cannot push operand " + argument.toString() + " in 'push' statement", stmt.src.location);
                return [];
        }
    }

    function resolveJumpCondition(program, stmt, result)
    {
        var flag;
        var cond = stmt.condition;
        var attr = cond.attr;
        var negated = cond.negated;
        if(!cond) {
            throw new Error('condition is null');
        }

        if(!attr) {
            switch(cond.branch) {
                case wiz.parse.Branch.Equal:
                    flag = Argument(ArgumentType.Zero);
                    break;
                case wiz.parse.Branch.NotEqual:
                    flag = Argument(ArgumentType.Zero);
                    negated = !negated;
                    break;
                case wiz.parse.Branch.Less:
                    flag = Argument(ArgumentType.Carry);
                    break;
                case wiz.parse.Branch.GreaterEqual:
                    flag = Argument(ArgumentType.Carry);
                    negated = !negated;
                    break;
                case wiz.parse.Branch.Greater:
                case wiz.parse.Branch.LessEqual:
                    error(
                        "comparision " + wiz.parse.getSimpleTokenName(cond.branch)
                        + " unsupported in 'when' clause", cond.location
                    );
                    return false;
            }
        } else {
            var def = wiz.compile.resolveAttribute(program, attr);
            if(wiz.sym.check('Builtin', def)) {
                switch(def.type) {
                    case ArgumentType.Carry:
                    case ArgumentType.Zero:
                        flag = Argument(def.type);
                        break;
                    default:
                }
            }
        }
        if(flag) {
            result.value = flag.getFlagIndex(negated);
            return true;
        } else {
            error(
                "unrecognized condition '" + attr.fullName
                + "' used in 'when' clause", cond.location
            );
            return false;
        }
    }

    function ensureUnconditional(stmt, context, code) {
        if(stmt.condition) {
            error("'when' clause is not allowed for " + context, stmt.condition.location);
            return [];
        } else {
            return code;
        }
    }

    function generateJump(program, stmt) {
        switch(stmt.type) {
            case wiz.parse.Keyword.Goto:
                var argument = buildArgument(program, stmt.destination);
                if(!argument) {
                    return [];
                }
                switch(argument.type) {
                    case ArgumentType.Immediate:
                        if(stmt.far) {
                            var address = {};
                            wiz.compile.foldWord(program, argument.immediate, program.finalized, address);
                            if(stmt.condition) {
                                var index = {};
                                if(resolveJumpCondition(program, stmt, index)) {
                                    return [(0xC2 + index.value * 0x08) & 0xFF, address.value & 0xFF, (address.value >> 8) & 0xFF];
                                }
                            } else {
                                return [0xC3, address.value & 0xFF, (address.value >> 8) & 0xFF];
                            }
                        } else {
                            var description = "relative jump";
                            var bank = program.checkBank(description, stmt.location);
                            var pc = bank.checkAddress(description, stmt.location);
                            var offset = {};
                            wiz.compile.foldRelativeByte(program, stmt.destination,
                                "relative jump distance",
                                "rewrite the branch, shorten the gaps in your code, or add a '!' far indicator.",
                                pc + 2, program.finalized, offset
                            );
                            if(stmt.condition) {
                                var index = {};
                                if(resolveJumpCondition(program, stmt, index)) {
                                    return [(0x20 + index.value * 0x08) & 0xFF, offset.value & 0xFF];
                                }
                            } else {
                                return [0x18, offset.value & 0xFF];
                            }
                        }
                        return [];
                    case ArgumentType.HL:
                        if(!stmt.condition) {
                            return [0xE9];
                        } else {
                            error("'goto hl' does not support 'when' clause", stmt.destination.location);
                        }
                        return [];
                    default:
                        error("unsupported argument to 'goto'", stmt.destination.location);
                        return [];
                }
            case wiz.parse.Keyword.Call:
                var argument = buildArgument(program, stmt.destination);
                if(!argument) {
                    return [];
                }
                switch(argument.type) {
                    case ArgumentType.Immediate:
                        var address = {};
                        wiz.compile.foldWord(program, argument.immediate, program.finalized, address);
                        if(stmt.condition) {
                            var index = {};
                            if(resolveJumpCondition(program, stmt, index)) {
                                return [(0xC4 + index.value * 0x08) & 0xFF, address.value & 0xFF, (address.value >> 8) & 0xFF];
                            }
                        } else {
                            return [0xCD, address.value & 0xFF, (address.value >> 8) & 0xFF];
                        }
                        return [];
                    default:
                        error("unsupported argument to 'call'", stmt.destination.location);
                        return [];
                }
            case wiz.parse.Keyword.Return:
                if(stmt.condition) {
                    var index = {};
                    if(resolveJumpCondition(program, stmt, index))
                    {
                        return [(0xC0 + index.value * 0x08) & 0xFF];
                    }
                } else {
                    return [0xC9];
                }
            case wiz.parse.Keyword.Resume: return ensureUnconditional(stmt, "'resume'", [0xD9]);
            case wiz.parse.Keyword.Abort: return ensureUnconditional(stmt,  "'abort'", [0x40]);
            case wiz.parse.Keyword.Sleep: return ensureUnconditional(stmt,  "'sleep'", [0x76]);
            case wiz.parse.Keyword.Suspend: return ensureUnconditional(stmt,  "'suspend'", [0x10, 0x00]);
            case wiz.parse.Keyword.Nop: return ensureUnconditional(stmt, "'nop'", [0x00]);
            default:
                error("instruction not supported", stmt.destination.location);
                return [];
        }
    }

    function generateComparison(program, stmt) {
        var left = buildArgument(program, stmt.left);
        var right = stmt.right ? buildArgument(program, stmt.right) : null;
        if(!left) {
            return [];
        }
        switch(left.type) {
            case ArgumentType.A:
                if(!right) {
                    // 'compare a' -> 'or a'
                    return [0xB7];
                } else {
                    // 'compare a to expr' -> 'cp a, expr'
                    switch(right.type) {
                        case ArgumentType.Immediate:
                            var value = {};
                            wiz.compile.foldWord(program, right.immediate, program.finalized, value);
                            return [0xFE, value.value & 0xFF];
                        case ArgumentType.B:
                        case ArgumentType.C:
                        case ArgumentType.D:
                        case ArgumentType.E:
                        case ArgumentType.H:
                        case ArgumentType.L:
                            return [(0xB8 + right.getRegisterIndex()) & 0xFF];
                        case ArgumentType.Indirection:
                            if(right.base.type == ArgumentType.HL) {
                                return [0xBE];
                            } else {
                                error("indirected operand in 'to' is not supported (only 'compare a to [hl]' is valid)", stmt.right.location);
                                return [];
                            }
                        case ArgumentType.A: return [0xBF];
                        default:
                            error("unsupported operand in 'to' clause of 'compare a to ...'", stmt.right.location);
                            return [];
                    }
                }
            case ArgumentType.BitIndex:
                // 'compare r@i' -> 'bit r, i'
                if(!right) {
                    var index = {};
                    if(!wiz.compile.foldBitIndex(program, left.immediate, program.finalized, index)) {
                        return [];
                    }
                    left = left.base;
                    switch(left.type) {
                        case ArgumentType.A: break;
                        case ArgumentType.B: break;
                        case ArgumentType.C: break;
                        case ArgumentType.D: break;
                        case ArgumentType.E: break;
                        case ArgumentType.H: break;
                        case ArgumentType.L: break;
                        case ArgumentType.Indirection:
                            if(left.base.type != ArgumentType.HL) {
                                error("indirected operand on left-hand side of '@' is not supported (only '[hl] @ ...' is valid)", stmt.right.location);
                                return [];
                            }
                            break;
                        default:
                            error("unsupported operand on left-hand side of '@'", stmt.right.location);
                            return [];
                    }
                    return [0xCB, (0x40 + index.value * 0x08 + left.getRegisterIndex()) & 0xFF];
                } else {
                    error("'to' clause is unsupported for 'compare ... @ ...'", stmt.right.location);
                    return [];
                }
            default:
                return [];
        }
    }

    function generateAssignment(program, stmt) {
        if(!stmt.src) {
            return generatePostfixAssignment(program, stmt);
        } else {
            var dest = buildArgument(program, stmt.dest);
            if(stmt.intermediary) {
                var intermediary = buildArgument(program, stmt.intermediary);
                // 'x = y via z' -> 'z = y; x = z'
                var result = generateCalculatedAssignment(program, stmt, intermediary, stmt.src);
                return result.push.apply(result, generateCalculatedAssignment(program, stmt, dest, stmt.intermediary)), result;
            } else {
                return generateCalculatedAssignment(program, stmt, dest, stmt.src);
            }
        }
    }

    function generatePostfixAssignment(program, stmt) {
        var dest = buildArgument(program, stmt.dest);
        var operatorIndex, operatorName;
        switch(stmt.postfix) {
            case wiz.parse.Postfix.Inc: operatorIndex = 0; operatorName = "'++'"; break;
            case wiz.parse.Postfix.Dec: operatorIndex = 1; operatorName = "'--'"; break;
        }

        if(!dest) {
            return [];
        }
        switch(dest.type) {
            case ArgumentType.A:
            case ArgumentType.B:
            case ArgumentType.C:
            case ArgumentType.D:
            case ArgumentType.E:
            case ArgumentType.H:
            case ArgumentType.L:
                return [(0x04 + operatorIndex + dest.getRegisterIndex() * 0x08) & 0xFF];
            case ArgumentType.Indirection:
                if(dest.base.type == ArgumentType.HL) {
                    return [(0x04 + operatorIndex + dest.getRegisterIndex() * 0x08) & 0xFF];
                } else {
                    error(stmt.dest.toString() + " cannot be operand of " + operatorName, stmt.dest.location);
                    return [];
                }
            case ArgumentType.BC:
            case ArgumentType.DE:
            case ArgumentType.HL:
            case ArgumentType.SP:
                return [(0x03 + (operatorIndex * 0x08) + dest.getPairIndex() * 0x10) & 0xFF];
            default:
                error(stmt.dest.toString() + " cannot be operand of " + operatorName, stmt.dest.location);
                return [];
        }
    }

    function generateCalculatedAssignment(program, stmt, dest, src)
    {
        if(!dest) {
            return [];
        }

        var infix = wiz.ast.check('Infix', src);
        if(infix) {
            var result = {};
            if(!wiz.compile.tryFoldConstant(program, infix, false, program.finalized, result)) {
                return [];
            }
            var constTail = result.constTail;
            var loadsrc = null;
            if(!constTail) {
                loadsrc = infix.operands[0];
            } else {
                loadsrc = wiz.ast.Number(wiz.parse.Token.Integer, result.value, constTail.location);
            }
            var code = getLoad(program, stmt, dest, loadsrc);
            var found = !constTail || constTail == infix.operands[0];
            for(var i = 0; i < infix.types.length; i++) {
                var type = infix.types[i];
                var node = infix.operands[i + 1];
                if(node == constTail) {
                    found = true;
                } else if(found) {
                    var operand = buildArgument(program, node);
                    if(!operand) {
                        return [];
                    }
                    if(i == 0 && patchStackPointerLoadOffset(program, type, node, dest, operand, loadsrc, code)) {
                        continue;
                    }
                    code.push.apply(code, getModify(program, type, node, dest, operand));
                }
            }
            return code;
        } else {
            return getLoad(program, stmt, dest, src);
        }
    }

    function patchStackPointerLoadOffset(program, type, node, dest, operand, loadsrc, code) {
        if(dest.type != ArgumentType.HL) {
            return false;
        }
        switch(type) {
            case wiz.parse.Infix.Add: break;
            case wiz.parse.Infix.Sub: break;
            default: return false;
        }
        switch(operand.type) {
            case ArgumentType.Immediate:
                var load = buildArgument(program, loadsrc);
                if(!load || load.type != ArgumentType.SP) {
                    return false;
                }

                var value = {};
                wiz.compile.foldSignedByte(program, operand.immediate, type == wiz.parse.Infix.Sub, program.finalized, value);
                // Monkey patch 'hl = sp + 00'
                code[code.length - 1] = value.value & 0xFF;
                return true;
            default:
                return false;
        }
    }

    function operatorError(type, dest, location) {
        error("infix operator " + wiz.parse.getSimpleTokenName(type) + " cannot be used in assignment '=' to " + dest.toString() + ".", location);
        return [];
    }

    function operandError(type, dest, operand, location) {
        error(operand.toString() + " cannot be operand of " + wiz.parse.getSimpleTokenName(type) + " in assignment '=' to " + dest.toString() + ".", location);
        return [];
    }

    function getModify(program, type, node, dest, operand) {
        switch(dest.type) {
            case ArgumentType.A:
                switch(type) {
                    case wiz.parse.Infix.Add:
                    case wiz.parse.Infix.AddC:
                    case wiz.parse.Infix.Sub:
                    case wiz.parse.Infix.SubC:
                    case wiz.parse.Infix.And:
                    case wiz.parse.Infix.Xor:
                    case wiz.parse.Infix.Or:
                        return getAccumulatorArithmetic(program, type, node, dest, operand);
                    case wiz.parse.Infix.ShiftL:
                    case wiz.parse.Infix.ShiftR:
                    case wiz.parse.Infix.ArithShiftL:
                    case wiz.parse.Infix.ArithShiftR:
                        return getRegisterShift(program, type, node, dest, operand);
                    case wiz.parse.Infix.RotateL:
                    case wiz.parse.Infix.RotateR:
                    case wiz.parse.Infix.RotateLC:
                    case wiz.parse.Infix.RotateRC:
                        return getAccumulatorShift(program, type, node, dest, operand);
                    default:
                        return operatorError(type, dest, node.location);
                }
            case ArgumentType.B:
            case ArgumentType.C:
            case ArgumentType.D:
            case ArgumentType.E:
            case ArgumentType.H:
            case ArgumentType.L:
                switch(type) {
                    case wiz.parse.Infix.RotateLC:
                    case wiz.parse.Infix.RotateRC:
                    case wiz.parse.Infix.RotateL:
                    case wiz.parse.Infix.RotateR:
                    case wiz.parse.Infix.ShiftL:
                    case wiz.parse.Infix.ShiftR:
                    case wiz.parse.Infix.ArithShiftL:
                    case wiz.parse.Infix.ArithShiftR:
                        return getRegisterShift(program, type, node, dest, operand);
                    default:
                       return operatorError(type, dest, node.location);
                }
            case ArgumentType.Indirection:
                switch(dest.base.type) {
                    // 'r = [hl]' -> 'ld r, [hl]'
                    case ArgumentType.HL:
                        switch(type) {
                            case wiz.parse.Infix.RotateLC:
                            case wiz.parse.Infix.RotateRC:
                            case wiz.parse.Infix.RotateL:
                            case wiz.parse.Infix.RotateR:
                            case wiz.parse.Infix.ShiftL:
                            case wiz.parse.Infix.ShiftR:
                            case wiz.parse.Infix.ArithShiftL:
                            case wiz.parse.Infix.ArithShiftR:
                                return getRegisterShift(program, type, node, dest, operand);
                            default:
                                return operatorError(type, dest, node.location);
                        }
                    default:
                        return operatorError(type, dest, node.location);
                }
            case ArgumentType.BC:
            case ArgumentType.DE:
                switch(type) {
                    case wiz.parse.Infix.ShiftL:
                    case wiz.parse.Infix.ShiftR:
                        return getPairShift(program, type, node, dest, operand);
                    default:
                        return operatorError(type, dest, node.location);
                }
            case ArgumentType.HL:
                switch(type) {
                    case wiz.parse.Infix.Add:
                        if(operand.type == ArgumentType.Immediate) {
                            return operandError(type, dest, operand, node.location);
                        } else {
                            return getHighLowArithmetic(program, type, node, dest, operand);
                        }
                    case wiz.parse.Infix.Sub:
                        return operatorError(type, dest, node.location);
                    case wiz.parse.Infix.ShiftL:
                    case wiz.parse.Infix.ShiftR:
                        return getPairShift(program, type, node, dest, operand);
                    default:
                        return operatorError(type, dest, node.location);
                }
            case ArgumentType.SP:
                switch(type) {
                    case wiz.parse.Infix.Add:
                    case wiz.parse.Infix.Sub:
                        return getStackPointerArithmetic(program, type, node, dest, operand);
                    default:
                        return operatorError(type, dest, node.location);
                }
            case ArgumentType.Carry:
                switch(type) {
                    case wiz.parse.Infix.Xor:
                        throw new Error('todo'); // TODO
                    default:
                        return operatorError(type, dest, node.location);
                }
                return [];
            default:
                return operandError(type, dest, operand, node.location);
        }
    }

    function getAccumulatorArithmetic(program, type, node, dest, operand) {
        var operatorIndex;
        switch(type) {
            case wiz.parse.Infix.Add: operatorIndex = 0; break;
            case wiz.parse.Infix.AddC: operatorIndex = 1; break;
            case wiz.parse.Infix.Sub: operatorIndex = 2; break;
            case wiz.parse.Infix.SubC: operatorIndex = 3; break;
            case wiz.parse.Infix.And: operatorIndex = 4; break;
            case wiz.parse.Infix.Xor: operatorIndex = 5; break;
            case wiz.parse.Infix.Or: operatorIndex = 6; break;
        }
        switch(operand.type) {
            case ArgumentType.Immediate:
                var value = {};
                wiz.compile.foldByte(program, operand.immediate, program.finalized, value);
                return [(0xC6 + operatorIndex * 0x08) & 0xFF, value.value & 0xFF];
            case ArgumentType.A:
            case ArgumentType.B:
            case ArgumentType.C:
            case ArgumentType.D:
            case ArgumentType.E:
            case ArgumentType.H:
            case ArgumentType.L:
                return [(0x80 + operatorIndex * 0x08 + operand.getRegisterIndex()) & 0xFF];
            case ArgumentType.Indirection:
                switch(operand.base.type) {
                    // 'r = [hl]' -> 'ld r, [hl]'
                    case ArgumentType.HL:
                        return [(0x80 + operatorIndex * 0x08 + operand.getRegisterIndex()) & 0xFF];
                        break;
                    default:
                        return operandError(type, dest, operand, node.location);
                }
                break;
            default:
                return operandError(type, dest, operand, node.location);
        }
    }


    function getHighLowArithmetic(program, type, node, dest, operand) {
        switch(operand.type) {
            case ArgumentType.BC:
            case ArgumentType.DE:
            case ArgumentType.HL:
            case ArgumentType.SP:
                return [(0x09 + operand.getPairIndex() * 0x10) & 0xFF];
                break;
            default:
                return operandError(type, dest, operand, node.location);
        }
    }

    function getStackPointerArithmetic(program, type, node, dest, operand) {
        switch(operand.type) {
            case ArgumentType.Immediate:
                var value = {};
                wiz.compile.foldSignedByte(program, operand.immediate, type == wiz.parse.Infix.Sub, program.finalized, value);
                return [0xE8, value.value & 0xFF];
            default:
                return operandError(type, dest, operand, node.location);
        }
    }

    function getAccumulatorShift(program, type, node, dest, operand) {
        var operatorIndex;
        switch(type) {
            case wiz.parse.Infix.RotateLC: operatorIndex = 0; break;
            case wiz.parse.Infix.RotateRC: operatorIndex = 1; break;
            case wiz.parse.Infix.RotateL: operatorIndex = 2; break;
            case wiz.parse.Infix.RotateR: operatorIndex = 3; break;
        }
        switch(operand.type) {
            case ArgumentType.Immediate:
                var value = {};
                if(!wiz.compile.foldBitIndex(program, operand.immediate, program.finalized, value)) {
                    return [];
                }
                var code = [];
                while(value.value--) {
                    code.push((0x07 + operatorIndex * 0x08) & 0xFF);
                }
                return code;
            default:
                return operandError(type, dest, operand, node.location);
        }
    }

    function getRegisterShiftIndex(type) {
        switch(type) {
            case wiz.parse.Infix.RotateLC: return 0;
            case wiz.parse.Infix.RotateRC: return 1;
            case wiz.parse.Infix.RotateL: return 2;
            case wiz.parse.Infix.RotateR: return 3;
            case wiz.parse.Infix.ArithShiftL: return 4;
            case wiz.parse.Infix.ArithShiftR: return 5;
            case wiz.parse.Infix.ShiftL: return 4; // Logical shl == arith shl
            case wiz.parse.Infix.ShiftR: return 7;
        };
    }

    function getRegisterShift(program, type, node, dest, operand) {
        var operatorIndex = getRegisterShiftIndex(type);
        switch(operand.type) {
            case ArgumentType.Immediate:
                var value = {};
                if(!wiz.compile.foldBitIndex(program, operand.immediate, program.finalized, value)) {
                    return [];
                }
                var code = [];
                while(value.value--) {
                    code.push(0xCB, (operatorIndex * 0x08 + dest.getRegisterIndex()) & 0xFF);
                }
                return code;
            default:
                return operandError(type, dest, operand, node.location);
        }
    }

    function getPairShift(program, type, node, dest, operand) {
        var shift;

        switch(type) {
            case wiz.parse.Infix.ShiftL:
                shift = [
                    // sla l
                    0xCB, (getRegisterShiftIndex(wiz.parse.Infix.ShiftL) * 0x08 + dest.getPairLowIndex()) & 0xFF,
                    // rl h
                    0xCB, (getRegisterShiftIndex(wiz.parse.Infix.RotateL) * 0x08 + dest.getPairHighIndex()) & 0xFF,
                ];
                break;
            case wiz.parse.Infix.ShiftR:
                shift = [
                    // sra h
                    0xCB, (getRegisterShiftIndex(wiz.parse.Infix.ShiftR) * 0x08 + dest.getPairHighIndex()) & 0xFF,
                    // rr l
                    0xCB, (getRegisterShiftIndex(wiz.parse.Infix.RotateR) * 0x08 + dest.getPairLowIndex()) & 0xFF,
                ];
                break;
        }
        switch(operand.type) {
            case ArgumentType.Immediate:
                var value = {};
                if(!wiz.compile.foldWordBitIndex(program, operand.immediate, program.finalized, value)) {
                    return [];
                }
                var code = [];
                while(value.value--) {
                    code.push.apply(code, shift);
                }
                return code;
            default:
                return operandError(type, dest, operand, node.location);
        }
    }

    function invalidAssignmentDestError(dest, location) {
        error("assignment '=' to " + dest.toString() + " is invalid.", location);
        return [];
    }

    function invalidAssignmentError(dest, load, location) {
        error("invalid assignment '=' of " + dest.toString() + " to " + load.toString() + ".", location);
        return [];
    }

    function getLoad(program, stmt, dest, loadsrc) {
        var load = buildArgument(program, loadsrc);
        if(load) {
            return getPrefixLoad(program, stmt, dest, load);
        } else {
            return [];
        }
    }

    function getPrefixLoad(program, stmt, dest, load) {
        switch(load.type) {
            // 'r = <>r' -> 'swap r'
            case ArgumentType.Swap:
                switch(dest.type) {
                    case ArgumentType.A:
                    case ArgumentType.B:
                    case ArgumentType.C:
                    case ArgumentType.D:
                    case ArgumentType.E:
                    case ArgumentType.H:
                    case ArgumentType.L:
                            var result = getPrefixLoad(program, stmt, dest, load.base);
                            return result.push(0xCB, (0x30 + dest.getRegisterIndex()) & 0xFF), result;
                    case ArgumentType.Indirection:
                        if(dest.base.type == ArgumentType.HL) {
                            var result = getPrefixLoad(program, stmt, dest, load.base);
                            return result.push(0xCB, (0x30 + dest.getRegisterIndex()) & 0xFF), result;
                        }
                    default:
                        return [];
                }
            // 'a = ~a' -> 'cpl a'
            case ArgumentType.Not:
                if(dest.type == ArgumentType.A) {
                    var result = getPrefixLoad(program, stmt, dest, load.base);
                    return result.push(0x2F), result;
                } else if(dest.type == ArgumentType.Carry) {
                    var result = getPrefixLoad(program, stmt, dest, load.base)
                    return result.push(0x3F), result;
                } else {
                    return invalidAssignmentError(dest, load, stmt.location);
                }
            // 'a = -a' -> 'cpl a, inc a'
            // 'carry = ~carry' -> 'ccf'
            case ArgumentType.Negated:
                if(dest.type == ArgumentType.A) {
                    var result = getPrefixLoad(program, stmt, dest, load.base);
                    return result.push(0x2F, 0x3C), result;
                } else {
                    return invalidAssignmentError(dest, load, stmt.location);
                }
            default:
                return getBaseLoad(program, stmt, dest, load);
        }
    }

    function getBaseLoad(program, stmt, dest, load) {
        switch(dest.type) {
            case ArgumentType.A:
                switch(load.type) {
                    // 'a = n' -> 'ld a, n'
                    case ArgumentType.Immediate:
                        return getRegisterLoadImmediate(program, stmt, dest, load);
                    // 'a = a' -> (nothing)
                    // 'a = r' -> 'ld a, r'
                    case ArgumentType.A:
                    case ArgumentType.B:
                    case ArgumentType.C:
                    case ArgumentType.D:
                    case ArgumentType.E:
                    case ArgumentType.H:
                    case ArgumentType.L:
                        return getRegisterLoadRegister(program, stmt, dest, load);
                    case ArgumentType.Indirection:
                        switch(load.base.type) {
                            case ArgumentType.Immediate:
                                return getAccumulatorLoadIndirectImmediate(program, stmt, load);
                            // 'a = [bc]' -> 'ld a, [bc]'
                            // 'a = [de]' -> 'ld a, [de]'
                            case ArgumentType.BC:
                            case ArgumentType.DE:
                                return getAccumulatorLoadIndirectPair(program, stmt, load);
                            // 'a = [hl]' -> 'ld a, [hl]'
                            case ArgumentType.HL: 
                                return getRegisterLoadRegister(program, stmt, dest, load);
                            default:
                                return invalidAssignmentError(dest, load, stmt.location);
                        }
                    case ArgumentType.IndirectionInc:
                    case ArgumentType.IndirectionDec:
                        switch(load.base.type) {
                            // 'a = [hl++]' -> 'ldi a, [hl]',
                            // 'a = [hl--]' -> 'ldd a, [hl]',
                            case ArgumentType.HL:
                                return getAccumulatorLoadIndirectIncrement(program, stmt, load);
                            default:
                                return invalidAssignmentError(dest, load, stmt.location);
                        }
                    case ArgumentType.PositiveIndex:
                        var value = {};
                        wiz.compile.foldWord(program, load.immediate, program.finalized, value);

                        if(value.value != 0xFF00 || load.base.type != ArgumentType.C) {
                            return invalidAssignmentError(dest, load, stmt.location);
                        } else {
                            return [0xF2];
                        }
                    default:
                        return invalidAssignmentError(dest, load, stmt.location);
                }
            case ArgumentType.B:
            case ArgumentType.C:
            case ArgumentType.D:
            case ArgumentType.E:
            case ArgumentType.H:
            case ArgumentType.L:
                switch(load.type) {
                    // 'r = n' -> 'ld r, n'
                    case ArgumentType.Immediate:
                        return getRegisterLoadImmediate(program, stmt, dest, load);
                    // 'r = r' -> (nothing)
                    // 'r = r2' -> 'ld r, r2'
                    case ArgumentType.A: 
                    case ArgumentType.B:
                    case ArgumentType.C:
                    case ArgumentType.D:
                    case ArgumentType.E:
                    case ArgumentType.H:
                    case ArgumentType.L:
                        return getRegisterLoadRegister(program, stmt, dest, load);
                    case ArgumentType.Indirection:
                        switch(load.base.type) {
                            // 'r = [hl]' -> 'ld r, [hl]'
                            case ArgumentType.HL:
                                return getRegisterLoadRegister(program, stmt, dest, load);
                            default:
                                return invalidAssignmentError(dest, load, stmt.location);
                        }
                    default:
                        return invalidAssignmentError(dest, load, stmt.location);
                }
            case ArgumentType.Indirection:
                switch(dest.base.type) {
                    case ArgumentType.Immediate:
                        if(load.type == ArgumentType.A) {
                            return getIndirectImmediateLoadAccumulator(program, stmt, dest);
                        } else {
                            return invalidAssignmentError(dest, load, stmt.location);
                        }
                    // '[bc] = a' -> 'ld [bc], a'
                    // '[de] = a' -> 'ld [de], a'
                    case ArgumentType.BC:
                    case ArgumentType.DE:
                        if(load.type == ArgumentType.A) {
                            return getIndirectPairLoadAccumulator(program, stmt, dest);
                        } else {
                            return invalidAssignmentError(dest, load, stmt.location);
                        }
                    case ArgumentType.HL:
                        switch(load.type)
                        {
                            // '[hl] = n' -> 'ld [hl], n'
                            case ArgumentType.Immediate:
                                return getRegisterLoadImmediate(program, stmt, dest, load);
                            // '[hl] = r' -> 'ld [hl], r'
                            case ArgumentType.A: 
                            case ArgumentType.B:
                            case ArgumentType.C:
                            case ArgumentType.D:
                            case ArgumentType.E:
                            case ArgumentType.H:
                            case ArgumentType.L:
                                return getRegisterLoadRegister(program, stmt, dest, load);
                            case ArgumentType.Indirection:
                                switch(load.base.type) {
                                    // '[hl] = [hl]' -> (nothing)
                                    case ArgumentType.HL:
                                        return [];
                                    default:
                                        return invalidAssignmentError(dest, load, stmt.location);
                                }
                            default:
                                return invalidAssignmentError(dest, load, stmt.location);
                        }
                    default:
                        return invalidAssignmentError(dest, load, stmt.location);
                }
            case ArgumentType.AF:
                switch(load.type) {
                    // 'af = pop' -> 'pop af'
                    case ArgumentType.Pop:
                        return getPairLoadPop(program, stmt, dest);
                    default:
                        return invalidAssignmentError(dest, load, stmt.location);
                }
            case ArgumentType.BC:
            case ArgumentType.DE:
            case ArgumentType.HL:
                switch(load.type) {
                    // 'rr = n' -> 'ld rr, n'
                    case ArgumentType.Immediate:
                        return getPairLoadImmediate(program, stmt, dest, load);
                    // 'rr = pop' -> 'pop rr'
                    case ArgumentType.Pop:
                        return getPairLoadPop(program, stmt, dest);
                    // 'hl = sp' -> 'ld hl, sp+0x0000'
                    case ArgumentType.SP:
                        if(dest.type == ArgumentType.HL) {
                            // 'hl = sp' -> 'ldhl sp,0'
                            return [0xF8, 0x00];
                        } else {
                            return invalidAssignmentError(dest, load, stmt.location);
                        }
                    // 'rr = rr' -> (none)
                    // 'hl = rr' -> 'ld hl, 0x0000; add hl, rr'
                    case ArgumentType.BC:
                    case ArgumentType.DE:
                    case ArgumentType.HL:
                        if(dest.type != load.type) {
                            if(dest.type == ArgumentType.HL) {
                                return getHighLowLoadPair(program, stmt, load);
                            } else {
                                return invalidAssignmentError(dest, load, stmt.location);
                            }
                        } else {
                            return [];
                        }
                    default:
                        return invalidAssignmentError(dest, load, stmt.location);
                }
            case ArgumentType.SP:
                switch(load.type) {
                    // 'sp = n' -> 'ld sp, n'
                    case ArgumentType.Immediate:
                        return getPairLoadImmediate(program, stmt, dest, load);
                    // sp = sp -> (none)
                    case ArgumentType.SP:
                        return [];
                    // 'sp = hl' -> 'ld sp, hl'
                    case ArgumentType.HL:
                        return [0xF9];
                    default:
                        return invalidAssignmentError(dest, load, stmt.location);
                }
            case ArgumentType.IndirectionInc:
            case ArgumentType.IndirectionDec:
                switch(load.type) {
                    case ArgumentType.A:
                        // '[hl++] = a' -> 'ld [hl+], a'
                        return getIndirectIncrementLoadAccumulator(program, stmt, dest);
                    default:
                        return invalidAssignmentError(dest, load, stmt.location);
                }
            case ArgumentType.PositiveIndex:
                var value = {};
                wiz.compile.foldWord(program, dest.immediate, program.finalized, value);

                if(value.value != 0xFF00 || dest.base.type != ArgumentType.C) {
                    error("assignment '=' to indexed memory location other than '[0xFF00:c]' is invalid.", stmt.location);
                    return [];
                }
                switch(load.type) {
                    // '[FF00:c]' -> 'ldh [c], a'
                    case ArgumentType.A:
                        return [0xE2];
                    default:
                        return invalidAssignmentError(dest, load, stmt.location);
                }
            case ArgumentType.BitIndex:
                var index = {};
                if(!wiz.compile.foldBitIndex(program, dest.immediate, program.finalized, index)) {
                    return [];
                }
                switch(dest.base.type) {
                    case ArgumentType.A: break;
                    case ArgumentType.B: break;
                    case ArgumentType.C: break;
                    case ArgumentType.D: break;
                    case ArgumentType.E: break;
                    case ArgumentType.H: break;
                    case ArgumentType.L: break;
                    case ArgumentType.Indirection:
                        if(dest.base.type != ArgumentType.HL) {
                            return invalidAssignmentError(dest, load, stmt.location);
                        }
                        break;
                    default:
                        return invalidAssignmentError(dest, load, stmt.location);
                }
                switch(load.type) {
                    // 'r@i = 0' -> 'res r, i'
                    // 'r@i = 1' -> 'set r, i'
                    case ArgumentType.Immediate:
                        var value = {};
                        if(!wiz.compile.foldBit(program, load.immediate, program.finalized, value)) {
                            return [];
                        }
                        if(value.value == 0) {
                            return [0xCB, (0x80 + index.value * 0x08 + dest.base.getRegisterIndex()) & 0xFF];
                        } else {
                            return [0xCB, (0xC0 + index.value * 0x08 + dest.base.getRegisterIndex()) & 0xFF];
                        }
                    default:
                        return invalidAssignmentError(dest, load, stmt.location);
                }
            case ArgumentType.Interrupt:
                switch(load.type) {
                    // 'interrupt = 0' -> 'di'
                    // 'interrupt = 1' -> 'ei'
                    case ArgumentType.Immediate:
                        var value = {};
                        if(!wiz.compile.foldBit(program, load.immediate, program.finalized, value)) {
                            return [];
                        }
                        if(value.value == 0) {
                            return [0xF3];
                        } else {
                            return [0xFB];
                        }
                    default:
                        return invalidAssignmentError(dest, load, stmt.location);
                }
            case ArgumentType.Pop:
            case ArgumentType.Immediate:
            case ArgumentType.Not:
            case ArgumentType.Negated:
            case ArgumentType.Swap:
            case ArgumentType.F:
            case ArgumentType.Zero:
            case ArgumentType.NegativeIndex:
                return invalidAssignmentDestError(dest, stmt.location);
            case ArgumentType.Carry:
                switch(load.type) {
                    case ArgumentType.Immediate:
                        var value = {};
                        if(!wiz.compile.foldBit(program, load.immediate, program.finalized, value)) {
                            return [];
                        }
                        // 'carry = 0' -> 'scf; ccf'    
                        if(value.value == 0) {
                            return [0x37, 0x3F];
                        }
                        // 'carry = 1' -> 'scf'
                        else {
                            return [0x37];
                        }
                    // 'carry = carry' -> (none)
                    case ArgumentType.Carry:
                        return [];
                    default:
                        return invalidAssignmentDestError(dest, stmt.location);
                }
                break;
            case ArgumentType.None:
                throw new Error("load must have argument");
        }
    }

    function getRegisterLoadImmediate(program, stmt, dest, load) {
        var value = {};
        wiz.compile.foldByte(program, load.immediate, program.finalized, value);
        return [(0x06 + dest.getRegisterIndex() * 0x08) & 0xFF, value.value & 0xFF];
    }

    function getRegisterLoadRegister(program, stmt, dest, load) {
        // ld r, r2, where r != r2 (we treat load self as empty code)
        if(dest.getRegisterIndex() != load.getRegisterIndex()) {
            return [(0x40 + dest.getRegisterIndex() * 0x08 + load.getRegisterIndex()) & 0xFF];
        }
        return [];
    }

    function getPairLoadImmediate(program, stmt, dest, load) {
        var value = {};
        wiz.compile.foldWord(program, load.immediate, program.finalized, value);
        return [(0x01 + dest.getPairIndex() * 0x10) & 0xFF, value.value & 0xFF, (value.value >> 8) & 0xFF];
    }

    function getPairLoadPop(program, stmt, dest) {
        return [(0xC1 + dest.getPairIndex() * 0x10) & 0xFF];
    }

    function getHighLowLoadPair(program, stmt, load) {
        return [0x21, 0x00, 0x00, (0x09 + load.getPairIndex() * 0x10) & 0xFF];
    }

    function getAccumulatorLoadIndirectImmediate(program, stmt, load) {
        var value = {};
        wiz.compile.foldWord(program, load.base.immediate, program.finalized, value);
        // 'a = [0xFFnn]' -> 'ldh a, [nn]'
        if((value.value & 0xFF00) == 0xFF00) {
            return [0xF0, value.value & 0xFF];
        }
        // 'a = [nnnn]' -> 'ld a, [nnnn]'
        else {
            return [0xFA, value.value & 0xFF, (value.value >> 8) & 0xFF];
        }
    }

    function getIndirectImmediateLoadAccumulator(program, stmt, dest) {
        var value = {};
        wiz.compile.foldWord(program, dest.base.immediate, program.finalized, value);
        // '[0xFFnn] = a' -> 'ldh [nn], a'
        if((value.value & 0xFF00) == 0xFF00) {
            return [0xE0, value.value & 0xFF];
        }
        // '[nnnn] = a' -> 'ld [nnnn], a'
        else {
            return [0xEA, value.value & 0xFF, (value.value >> 8) & 0xFF];
        }
    }

    function getAccumulatorLoadIndirectPair(program, stmt, load) {
        return [(0x0A + load.base.getPairIndex() * 0x10) & 0xFF];
    }

    function getIndirectPairLoadAccumulator(program, stmt, dest) {
        return [(0x02 + dest.base.getPairIndex() * 0x10) & 0xFF];
    }

    function getAccumulatorLoadIndirectIncrement(program, stmt, load) {
        switch(load.type) {
            case ArgumentType.IndirectionInc: return [0x2A];
            case ArgumentType.IndirectionDec: return [0x3A];
        }
    }

    function getIndirectIncrementLoadAccumulator(program, stmt, dest) {
        switch(dest.type) {
            case ArgumentType.IndirectionInc: return [0x22];
            case ArgumentType.IndirectionDec: return [0x32];
        }
    }

    return that;
}

})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.cpu = typeof(wiz.cpu) !== 'undefined' ? wiz.cpu : {};
    wiz.cpu.mos6502 = typeof(wiz.cpu.mos6502) !== 'undefined' ? wiz.cpu.mos6502 : {};

    wiz.cpu.mos6502.Mos6502Platform = function() {
        var that = wiz.cpu.AbstractPlatform();
        // TODO
        return that;
    }
})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.compile = typeof(wiz.compile) !== 'undefined' ? wiz.compile : {};

    wiz.compile.Bank = function(name, physical, capacity) {
        var that = {};

        var PadValue = 0xFF;

        // The name of this bank.
        that.name = name;
        // Until a ROM relocation occurs, this page is not initialized.
        that.initialized = false;
        // Origin point as an absolute memory address where this bank starts.
        that.origin = 0;
        // The position, in bytes, into the bank.
        that.position = 0;
        // Whether or not this bank needs physical storage in the ROM.
        that.physical = physical;
        // The total size of this bank, used to prevent write overflows, and calculate space in the ROM.
        that.capacity = capacity;
        // The ROM data held by this bank.
        that.data = new Uint8Array(0);

        if(that.physical) {
            that.data = new Uint8Array(capacity);
            (function() {
                for(var i = 0; i < that.capacity; i++) {
                    that.data[i] = PadValue;
                }
            })();
        }

        that.reserve = function(description, size, location) {
            if(that.initialized) {
                if(that.position + size > that.capacity) {
                    wiz.compile.error(
                        description + " needs " + size + " byte(s), which exceeds the remaining space in '"
                        + that.name + " :  " + (that.physical ? "rom" : "ram") + " * " + that.capacity
                        + "' by " + (that.position + size - that.capacity) + " byte(s)",
                        location, true
                    );
                }
                else {
                    that.position += size;
                }
            } else {
                wiz.compile.error(
                    description + " found inside '"
                    + that.name + " :  " + (that.physical ? "rom" : "ram") + " * " + that.capacity
                    + "', but the bank has no address yet.",
                    location, true
                );
            }
        }

        that.rewind = function() {
            that.position = 0;
            that.initialized = false;
        }
        
        that.reserveVirtual = function(description, size, location) {
            if(that.physical) {
                wiz.compile.error(
                    description + " is not allowed in '"
                    + name + " : rom * " + that.capacity + "'",
                    location, true
                );
            } else {
                that.reserve(description, size, location);
            }
        }

        that.reservePhysical = function(description, size, location) {
            if(that.physical) {
                that.reserve(description, size, location);
            } else {
                wiz.compile.error(
                    description + " is not allowed in '"
                    + name + " : ram * " + that.capacity + "'",
                    location, true
                );
            }
        }

        that.writePhysical = function(items, location) {
            if(that.position + items.length > that.capacity) {
                wiz.compile.error("attempt to write outside of bank's reserved space.", location, true);
            } else {
                for(var i = 0; i < items.length; i++) {
                    that.data[that.position++] = items[i] & 0xFF;
                }
            }
        }

        that.checkAddress = function(description, location) {
            if(that.initialized) {
                return that.origin + that.position;
            } else {
                wiz.compile.error(
                    description + " is not allowed in '"
                    + that.name + " :  " + (that.physical ? "rom" : "ram") + " * " + that.capacity
                    + "' before knowing its start address.",
                    location, true
                );
                return 0xFACEBEEF;
            }
        }

        function paddedHex(value, width) {
            var width = 4;
            value = value.toString(16);
            return address.length >= width ? value : new Array(4 - value.length + 1).join('0') + value;
        }

        that.setAddress = function(description, dest, location) {
            if(that.initialized) {
                if(that.dest < that.origin + that.position) {
                    wiz.compile.error(
                        "attempt to move backwards within '"
                        + that.name + " :  " + (that.physical ? "rom" : "ram") + " * " + that.capacity
                        + "'. (location 0x" + paddedHex(that.origin + that.position, 4) + " -> 0x" + paddedHex(dest, 4) + ")",
                        location, true
                    );
                } else {
                    that.reserve(description, dest - (that.origin + that.position), location);
                }
            } else {
                if(dest + that.capacity > 65536) {
                    wiz.compile.error(
                        "'"
                        + that.name + " :  " + (that.physical ? "rom" : "ram") + " * " + that.capacity
                        + "' with start location " + dest + " (0x" + paddedHex(dest, 4) + ") has an invalid upper bound "
                        + (dest + that.capacity) + " (0x" + paddedHex(dest + that.capacity, 4) + "), outside of addressable memory 0..65535.",
                        location, true
                    );              
                }
                that.origin = dest;
                that.initialized = true;
            }
        }


        that.dump = function(buffer) {
            if(that.physical) {
                var data = that.data;
                var len = that.data.length;
                for(var i = 0; i < len; i++) {
                    buffer.push(data[i]);
                }
            }
        }

        return that;
    };
})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.compile = typeof(wiz.compile) !== 'undefined' ? wiz.compile : {};

    wiz.compile.resolveAttribute = function(program, attribute, quiet) {
        var prev = null;
        var def = null;
        var partialQualifiers = [];
        var env = program.environment;
        
        for(var i = 0; i < attribute.pieces.length; i++) {
            var piece = attribute.pieces[i];
            partialQualifiers.push(piece);
            
            if(!prev) {
                def = env.get(piece);
            } else {
                var pkg = wiz.sym.check('PackageDef', prev);
                if(!pkg) {
                    var previousName = partialQualifiers.slice(0, partialQualifiers.length - 1).join(".");
                    wiz.compile.error("attempt to get symbol '" + attribute.fullName + "', but '" + previousName + "' is not a package", attribute.location);
                } else {
                    env = pkg.environment;
                    def = env.get(piece, true); // qualified lookup is shallow.
                }
            }
            
            if(!def) {
                var partiallyQualifiedName = partialQualifiers.join(".");
                var fullyQualifiedName = attribute.fullName;
                
                if(!quiet) {
                    if(partiallyQualifiedName == fullyQualifiedName) {
                        wiz.compile.error("reference to undeclared symbol '" + partiallyQualifiedName + "'", attribute.location);
                    } else {
                        wiz.compile.error("reference to undeclared symbol '" + partiallyQualifiedName + "' (in '" + fullyQualifiedName + "')", attribute.location);
                    }
                }
                return null;
            }
            
            prev = def;
        }
        return def;
    }

    wiz.compile.tryFoldConstant = function(program, root, runtimeForbidden, finalized, result) {
        var values = {}; // Expression -> uint
        var completeness = {} // Expression -> bool
        var runtimeRootForbidden = runtimeForbidden;
        var badAttr = false;
        var depth = 0;

        function updateValue(node, value, complete) {
            complete = typeof(complete) !== 'undefined' ? complete : true;
            values[node.nodeId] = value;
            completeness[node.nodeId] = complete;
            if(depth == 0 && complete) {
                result.constTail = node;
            }
        }

        result.constTail = null;
        wiz.compile.traverse(root, {
            Infix: function(e) {
                var first = e.operands[0];

                if(typeof(values[first.nodeId]) === 'undefined') {
                    if(depth == 0) {
                        result.constTail = null;
                    }
                    return;
                }

                var a = values[first.nodeId];
                updateValue(e, a, false);

                for(var i = 0; i < e.types.length; i++) {
                    var type = e.types[i];
                    var operand = e.operands[i + 1];
                    if(typeof(values[operand.nodeId]) === 'undefined') {
                        if(depth == 0) {
                            result.constTail = e.operands[i];
                        }
                        return;
                    }
                    var b = values[operand.nodeId];

                    switch(type) {
                        case wiz.parse.Infix.Add: 
                            if((a + b) % wiz.ast.Expression.Max < a) {
                                wiz.compile.error("addition yields result which will overflow outside of 0..65535.", operand.location);
                                return;
                            } else {
                                a += b;
                            }
                            break;
                        case wiz.parse.Infix.Sub:
                            if(a < b) {
                                wiz.compile.error("subtraction yields result which will overflow outside of 0..65535.", operand.location);
                                return;
                            } else {
                                a -= b;
                            }
                            break;
                        case wiz.parse.Infix.Mul:
                            if(b != 0 && a > Math.floor(wiz.ast.Expression.Max / b))
                            {
                                wiz.compile.error("multiplication yields result which will overflow outside of 0..65535.", operand.location);
                                return;
                            } else {
                                a *= b;
                            }
                            break;
                        case wiz.parse.Infix.Div:
                            if(a == 0) {
                                wiz.compile.error("division by zero is undefined.", operand.location);
                                return;
                            } else {
                                a = Math.floor(a / b);
                            }
                            break;
                        case wiz.parse.Infix.Mod:
                            if(a == 0) {
                                wiz.compile.error("modulo by zero is undefined.", operand.location);
                                return;
                            } else {
                                a %= b;
                            }
                            break;
                        case wiz.parse.Infix.ShiftL:
                            // If shifting more than N bits, or ls << rs > 2^N-1, then wiz.compile.error.
                            if(b > 15 || (a << b >> 16) != 0) {
                                wiz.compile.error("logical shift left yields result which will overflow outside of 0..65535.", operand.location);
                                return;
                            } else {
                                a <<= b;
                            }
                            break;
                        case wiz.parse.Infix.ShiftR:
                            a >>= b;
                            break;
                        case wiz.parse.Infix.And:
                            a &= b;
                            break;
                        case wiz.parse.Infix.Or:
                            a |= b;
                            break;
                        case wiz.parse.Infix.Xor:
                            a ^= b;
                            break;
                        case wiz.parse.Infix.At:
                            a &= (1 << b);
                            break;
                        case wiz.parse.Infix.AddC:
                        case wiz.parse.Infix.SubC:
                        case wiz.parse.Infix.ArithShiftL:
                        case wiz.parse.Infix.ArithShiftR:
                        case wiz.parse.Infix.RotateL:
                        case wiz.parse.Infix.RotateR:
                        case wiz.parse.Infix.RotateLC:
                        case wiz.parse.Infix.RotateRC:
                        case wiz.parse.Infix.Colon:
                        default:
                            if(runtimeForbidden) {
                                wiz.compile.error("infix operator " + wiz.parse.getInfixName(type) + " cannot be used in constant expression", operand.location);
                            }
                            if(depth == 0) {
                                result.constTail = e.operands[i];
                            }
                            return;
                    }
                    updateValue(e, a, i == e.types.length - 1);
                }
            },

            Prefix: {
                pre: function(e) {
                    if(e.type == wiz.parse.Prefix.Grouping) {
                        depth++;
                        runtimeForbidden = false;
                    } else if(e.type == wiz.parse.Prefix.Indirection) {
                        depth++;
                    }
                },
                post: function(e) {
                    switch(e.type) {
                        case wiz.parse.Prefix.Low:
                        case wiz.parse.Prefix.High:
                        case wiz.parse.Prefix.Swap:
                            break;
                        case wiz.parse.Prefix.Grouping:
                            depth--;
                            if(depth == 0) {
                                runtimeForbidden = runtimeRootForbidden;
                            }
                            break;
                        case wiz.parse.Prefix.Not:
                        case wiz.parse.Prefix.Sub:
                            if(runtimeForbidden) {
                                wiz.compile.error("prefix operator " + wiz.parse.getPrefixName(e.type) + " cannot be used in constant expression", e.location);
                            }
                            return;
                        case wiz.parse.Prefix.Indirection:
                            depth--;
                            if(runtimeForbidden) {
                                wiz.compile.error("indirection operator cannot be used in constant expression", e.location);
                            }
                            return;
                    }
                    
                    if(typeof(values[e.operand.nodeId]) === 'undefined') {
                        return;
                    }
                    var r = values[e.operand.nodeId];
                    switch(e.type) {
                        case wiz.parse.Prefix.Low:
                            updateValue(e, r & 0xFF);
                            break;
                        case wiz.parse.Prefix.High:
                            updateValue(e, (r >> 8) & 0xFF);
                            break;
                        case wiz.parse.Prefix.Swap:
                            updateValue(e, ((r & 0x0F0F) << 4) | ((r & 0xF0F0) >> 4));
                            break;
                        case wiz.parse.Prefix.Grouping:
                            updateValue(e, r);
                            break;
                        case wiz.parse.Prefix.Not:
                        case wiz.parse.Prefix.Indirection:
                        case wiz.parse.Prefix.Sub:
                            break;
                    }
                }
            },

            Postfix: function(e) {
                if(typeof(values[e.operand.nodeId]) === 'undefined') {
                    return;
                } else {
                    if(runtimeForbidden) {
                        wiz.compile.error("postfix operator " + wiz.parse.getPostfixName(e.type) + " cannot be used in constant expression", e.location);
                    }
                }
            },

            Attribute: function(a) {
                var def = wiz.compile.resolveAttribute(program, a);
                if(!def) {
                    badAttr = true;
                    return;
                }
                if(wiz.sym.check('ConstDef', def)) {
                    program.enterInline("constant '" + a.fullName + "'", a);
                    program.enterEnvironment(def.environment);
                    var v = {};
                    var folded = wiz.compile.foldConstant(program, def.decl.value, program.finalized, v);
                    program.leaveEnvironment();
                    program.leaveInline();
                    if(folded) {
                        updateValue(a, v.value);
                        return;
                    }
                } else if(wiz.sym.check('VarDef', def)) {
                    if(def.hasAddress) {
                        updateValue(a, def.address);
                        return;
                    }
                } else if(wiz.sym.check('LabelDef', def)) {
                    if(def.hasAddress) {
                        updateValue(a, def.address);
                        return;
                    }
                }

                if(def && runtimeForbidden && finalized) {
                    wiz.compile.error("'" + a.fullName + "' was declared, but could not be evaluated.", a.location);
                }
            },

            String: function(s) {
                wiz.compile.error("string literal is not allowed here", s.location);
            },

            Number: function(n) {
                updateValue(n, n.value);
            },
        });

        result.value = typeof(values[root.nodeId]) !== 'undefined' ? values[root.nodeId] : 0xCACA;
        if(!completeness[root.nodeId] && runtimeForbidden && finalized) {
            wiz.compile.error("expression could not be resolved as a constant", root.location);
            result.constTail = null;
            return false;
        }
        if(badAttr) {
            result.constTail = null;
            return false;
        }
        return true;
    }

    wiz.compile.foldConstant = function(program, root, finalized, result) {
        return wiz.compile.tryFoldConstant(program, root, true, finalized, result) && result.constTail == root;
    }

    wiz.compile.foldBoundedNumber = function(program, root, type, limit, finalized, result) {
        if(wiz.compile.foldConstant(program, root, finalized, result)) {
            if(result.value > limit) {
                wiz.compile.error(
                    "value " + result.value + " is outside of representable " + type + " range 0.." + limit,
                    root.location
                );
                return false;
            }
            return true;
        }
        return false;
    }

    wiz.compile.foldBit = function(program, root, finalized, result) {
        return wiz.compile.foldBoundedNumber(program, root, "bit", 1, finalized, result);
    }

    wiz.compile.foldBitIndex = function(program, root, finalized, result) {
        return wiz.compile.foldBoundedNumber(program, root, "bitwise index", 7, finalized, result);
    }

    wiz.compile.foldWordBitIndex = function(program, root, finalized, result) {
        return wiz.compile.foldBoundedNumber(program, root, "bitwise index", 15, finalized, result);
    }

    wiz.compile.foldByte = function(program, root, finalized, result) {
        return wiz.compile.foldBoundedNumber(program, root, "8-bit", 255, finalized, result);
    }

    wiz.compile.foldWord = function(program, root, finalized, result) {
        return wiz.compile.foldBoundedNumber(program, root, "16-bit", 65535, finalized, result);
    }

    wiz.compile.foldSignedByte = function(program, root, finalized, result) {
        if(wiz.compile.foldWord(program, root, finalized, result)) {
            if(!negative && result.value < 127) {
                return true;
            } else if(negative && result.value < 128) {
                result.value = ~result.value + 1;
                return true;
            } else {
                wiz.compile.error(
                    "value " + (negative ? "-" : "") + result.value + " is outside of representable signed 8-bit range -128..127.",
                    root.location
                );
            }
        }
        return false;
    }

    wiz.compile.foldRelativeByte = function(program, root, description, help, origin, finalized, result) {
        if(wiz.compile.foldWord(program, root, finalized, result)) {
            var offset = result.value - origin;
            if(offset >= -128 && offset <= 127) {
                result.value = offset & 255;
                return true;
            } else {
                wiz.compile.error(
                    description + " is outside of representable signed 8-bit range -128..127. "
                    + help + " (from = " + origin + ", to = " + result.value + ", (from - to) = " + offset + ")",
                    root.location
                );
            }
        }
        return false;
    }

    wiz.compile.foldStorage = function(program, s, result) {
        result.sizeless = false;
        if(!s.size) {
            result.sizeless = true;
            result.value = 1;
        } else if(!wiz.compile.foldConstant(program, s.size, true, result)) {
            return false;
        }
        switch(s.type) {
            case wiz.parse.Keyword.Byte: result.unit = 1; break;
            case wiz.parse.Keyword.Word: result.unit = 2; break;
            default:
                wiz.compile.error("Unsupported storage type " + wiz.parse.getKeywordName(s.type), s.location);
        }
        result.value *= result.unit;
        return true;
    }

    wiz.compile.foldDataExpression = function(program, root, unit, finalized) {
        switch(unit) {
            case 1:
                if(wiz.ast.check('String', root)) {
                    return root.value;
                } else {
                    var result = {};
                    wiz.compile.foldByte(program, root, finalized, result);
                    return [result.value & 0xFF];
                }
            case 2:
                var result = {};
                wiz.compile.foldWord(program, root, finalized, result);
                return [result.value & 0xFF, (result.value >> 8) & 0xFF];
            default:
                throw new Error("unhandled unit size");
        }
    }

    wiz.compile.createBlockHandler = function(program) {
        return {
            pre: function(block) {
                var env = program.nextNodeEnvironment(block);
                if(!env) {
                    if(block.name) {
                        var match = program.environment.get(block.name, true);
                        if(wiz.sym.check('PackageDef', match)) {
                            env = match.environment;
                        } else {
                            env = wiz.compile.Environment(program.environment);
                        }
                    } else {
                        env = wiz.compile.Environment(program.environment);
                    }
                    program.createNodeEnvironment(block, env);
                }
                program.enterEnvironment(env);
            },
            post: function(block) {
                var pkg = program.environment;
                program.leaveEnvironment();
                if(block.name) {
                    var match = program.environment.get(block.name, true);
                    if(wiz.sym.check('PackageDef', match) === null) {
                        program.environment.put(block.name, wiz.sym.PackageDef(block, pkg));
                    }
                }
            }
        };
    }

    wiz.compile.createRelocationHandler = function(program) {
        return function(stmt) {
            var description = "'in' statement";
            var address = {};
            if(!stmt.dest || wiz.compile.foldConstant(program, stmt.dest, program.finalized, address)) {
                var def = wiz.sym.check('BankDef', program.environment.get(stmt.mangledName));
                if(def) {
                    program.switchBank(def.bank);
                    if(stmt.dest) {
                        def.bank.setAddress(description, address.value, stmt.location);
                    }
                } else {
                    wiz.compile.error("unknown bank '" + stmt.name + "' referenced by " + description, stmt.location);
                }
            }
        };
    }

    wiz.compile.createPushHandler = function(program) {
        return function(stmt) {
            var description = "'push' statement";
            var code = program.platform.generatePush(program, stmt);
            var bank = program.checkBank(description, stmt.location);
            if(program.finalized) {
                bank.writePhysical(code, stmt.location);
            } else {
                bank.reservePhysical(description, code.length, stmt.location);
            }
        };
    }

    wiz.compile.createInlineCallValidator = function(program) {
        return {
            pre: function(stmt) {
                if(stmt.type == wiz.parse.Keyword.Inline) {
                    program.enterInline("'inline call'", stmt);
                }
            },
            post: function(stmt)  {
                if(stmt.type == wiz.parse.Keyword.Inline) {
                    program.leaveInline();
                }
            }
        };
    }

    wiz.compile.createJumpHandler = function(program) {
        return {
            pre: function(stmt) {
                if(stmt.type == wiz.parse.Keyword.Inline) {
                    program.enterInline("'inline call'", stmt);
                }
            },
            post: function(stmt) {
                if(stmt.type == wiz.parse.Keyword.Inline) {
                    program.leaveInline();
                    return;
                }
                var description = wiz.parse.getKeywordName(stmt.type) + " statement";
                var code = program.platform.generateJump(program, stmt);
                var bank = program.checkBank(description, stmt.location);
                if(program.finalized) {
                    bank.writePhysical(code, stmt.location);
                } else {
                    bank.reservePhysical(description, code.length, stmt.location);
                }
            }
        };
    }

    wiz.compile.createAssignmentHandler = function(program) {
        return function(stmt) {
            var description = "assignment";
            var code = program.platform.generateAssignment(program, stmt);
            var bank = program.checkBank(description, stmt.location);
            if(program.finalized) {
                bank.writePhysical(code, stmt.location);
            } else {
                bank.reservePhysical(description, code.length, stmt.location);
            }
        };
    }

    wiz.compile.createComparisonHandler = function(program) {
        return function(stmt) {
            var description = "comparison";
            var code = program.platform.generateComparison(program, stmt);
            var bank = program.checkBank(description, stmt.location);
            if(program.finalized) {
                bank.writePhysical(code, stmt.location);
            } else {
                bank.reservePhysical(description, code.length, stmt.location);
            }
        };
    }

    wiz.compile.build = function(program, root) {
        program.rewind();
        wiz.compile.traverse(root, {
            Block: wiz.compile.createBlockHandler(program),

            LetDecl: function(decl) {
                program.environment.put(decl.name, wiz.sym.ConstDef(decl, program.environment));
            },

            Conditional: function(cond) {
                cond.expand();
            },

            Loop: function(loop) {
                loop.expand();
            },

            FuncDecl: function(decl) {
                decl.expand();
                program.environment.put(decl.name, wiz.sym.FuncDef(decl));
            },

            Unroll: function(unroll) {
                var times = {};
                if(wiz.compile.foldConstant(program, unroll.repetitions, true, times)) {
                    unroll.expand(times.value);
                }
            }
        });

        var depth = 0;
        program.rewind();
        wiz.compile.traverse(root, {
            Block: wiz.compile.createBlockHandler(program),

            Loop: {
                pre: function(loop) {
                    depth++;
                },
                post: function(loop) {
                    depth--;
                }
            },

            Jump: function(jump) {
                switch(jump.type) {
                    case wiz.parse.Keyword.While:
                    case wiz.parse.Keyword.Until:
                    case wiz.parse.Keyword.Break:
                    case wiz.parse.Keyword.Continue:
                        if(depth == 0) {
                            wiz.compile.error("'" + wiz.parse.getKeywordName(jump.type) + "' used outside of a 'loop'.", jump.location);
                        } else {
                            jump.expand();
                        }
                        break;
                    case wiz.parse.Keyword.Call:
                        var a = wiz.ast.check('Attribute', jump.destination);
                        if(a) {
                            var def = wiz.compile.resolveAttribute(program, a, true);
                            if(wiz.sym.check('FuncDef', def)) {
                                if(def.decl.inlined) {
                                    wiz.compile.error("call to inline function '" + a.fullName + "' must be 'inline call'.", jump.location);
                                }
                            }
                        }
                        break;
                    case wiz.parse.Keyword.Inline:
                        var a = wiz.ast.check('Attribute', jump.destination);
                        if(a) {
                            var def = wiz.compile.resolveAttribute(program, a);
                            if(def) {
                                if(wiz.sym.check('FuncDef', def)) {
                                    jump.expand(def.decl.inner);
                                } else {
                                    wiz.compile.error("an inline call to a non-function really makes no sense.", jump.location);
                                }
                            }
                        } else {
                            wiz.compile.error("an inline call to a non-function really makes no sense.", jump.location);
                        }
                        break;
                    default:
                }
            }
        });

        wiz.compile.verify();

        program.clearEnvironment();
        program.rewind();
        wiz.compile.traverse(root, {
            Block: wiz.compile.createBlockHandler(program),
            Jump: wiz.compile.createInlineCallValidator(program),

            LetDecl: function(decl) {
                var aliasing = false;
                var attr = wiz.ast.check('Attribute', decl.value);
                if(attr) {
                    var def = wiz.compile.resolveAttribute(program, attr, true);
                    if(def) {
                        aliasing = true;
                        program.environment.put(decl.name, wiz.sym.AliasDef(decl, def));
                    }
                }
                if(!aliasing) {
                    program.environment.put(decl.name, wiz.sym.ConstDef(decl, program.environment));
                }
            },

            BankDecl: function(decl) {
                for(var i = 0; i < decl.names.length; i++) {
                    program.environment.put(decl.names[i], wiz.sym.BankDef(decl));
                }
            },

            VarDecl: function(decl) {
                for(var i = 0; i < decl.names.length; i++) {
                    program.environment.put(decl.names[i], wiz.sym.VarDef(decl));
                }
            },

            LabelDecl: function(decl) {
                program.environment.put(decl.name, wiz.sym.LabelDef(decl));
            },
        });

        program.rewind();
        wiz.compile.traverse(root, {
            Block: wiz.compile.createBlockHandler(program),

            BankDecl: function(decl) {
                var size = {};
                if(wiz.compile.foldConstant(program, decl.size, true, size)) {
                    for(var i = 0; i < decl.names.length; i++) {
                        var name = decl.names[i];
                        var def = wiz.sym.check('BankDef', program.environment.get(name));
                        if(def) {
                            def.bank = wiz.compile.Bank(name, decl.type == "rom", size.value);
                            program.addBank(def.bank);
                        }
                    }
                }
            }
        });
        wiz.compile.verify();

        program.rewind();
        wiz.compile.traverse(root, {
            Block: wiz.compile.createBlockHandler(program),
            Relocation: wiz.compile.createRelocationHandler(program),

            VarDecl: function(decl) {
                var description = "variable declaration";
                var result = {};
                if(wiz.compile.foldStorage(program, decl.storage, result)) {
                    var bank = program.checkBank(description, decl.location);
                    for(var i = 0; i < decl.names.length; i++) {
                        var def = wiz.sym.check('VarDef', program.environment.get(decl.names[i]));
                        if(def) {
                            def.hasAddress = true;
                            def.address = bank.checkAddress(description, decl.location);
                            bank.reserveVirtual(description, result.value, decl.location);
                        }
                    }
                }
            },
        });
        wiz.compile.verify();

        program.rewind();
        wiz.compile.traverse(root, {
            Block: wiz.compile.createBlockHandler(program),
            Relocation: wiz.compile.createRelocationHandler(program),
            Push: wiz.compile.createPushHandler(program),
            Jump: wiz.compile.createJumpHandler(program),
            Assignment: wiz.compile.createAssignmentHandler(program),
            Comparison: wiz.compile.createComparisonHandler(program),

            LabelDecl: function(decl) {
                var description = "label declaration";
                var bank = program.checkBank(description, decl.location);
                var def = wiz.sym.check('LabelDef', program.environment.get(decl.name));
                if(def) {
                    def.hasAddress = true;
                    def.address = bank.checkAddress(description, decl.location);
                }
            },

            Embed: function(stmt) {
                var description = "'embed' statement";

                var file = wiz.fs.open(filename);
                if(!file) {
                    wiz.compile.error("could not embed file '" + stmt.filename + "'", stmt.location, true);
                    return;
                }
                stmt.data = file.readBinary();
                
                var bank = program.checkBank(description, stmt.location);
                bank.reservePhysical(description, stmt.data.length, stmt.location);
            },

            Data: function(stmt) {
                var description = "inline data";
                var result = {};
                if(wiz.compile.foldStorage(program, stmt.storage, result)) {
                    var data = [];
                    if(!stmt.items.length) {
                        throw new Error('no items in data statement');
                    }
                    for(var i = 0; i < stmt.items.length; i++) {
                        var item = stmt.items[i];
                        var bytes = wiz.compile.foldDataExpression(program, item, result.unit, program.finalized);
                        for(var j = 0; j < bytes.length; j++) {
                            data.push(bytes[j]);
                        }
                    }
                    if(!result.sizeless) {
                        if(data.length < result.value) {
                            // Fill unused section with final byte of data.
                            var pad = data[data.length - 1];
                            var k = result.value - data.length;
                            while(k > 0) {
                                data.push(pad);
                                k--;
                            }
                        } else if(data.length > result.value) {
                            wiz.compile.error(
                                description + " is an " + data.length + "-byte sequence, which is "
                                + (data.length - result.value) + " byte(s) over the declared "
                                + result.value + "-byte limit",
                                stmt.location
                            );
                        }
                    }
                    var bank = program.checkBank(description, stmt.location);
                    bank.reservePhysical(description, data.length, stmt.location);
                }
            }
        });
        wiz.compile.verify();

        program.finalized = true;
        program.rewind();
        wiz.compile.traverse(root, {
            Block: wiz.compile.createBlockHandler(program),
            Relocation: wiz.compile.createRelocationHandler(program),
            Push: wiz.compile.createPushHandler(program),
            Jump: wiz.compile.createJumpHandler(program),
            Assignment: wiz.compile.createAssignmentHandler(program),
            Comparison: wiz.compile.createComparisonHandler(program),

            LabelDecl: function(decl) {
                var description = "label declaration";
                var bank = program.checkBank(description, decl.location);
                var def = wiz.sym.check('LabelDef', program.environment.get(name));
                if(def) {
                    var addr = bank.checkAddress(description, decl.location);
                    if(!def.hasAddress) {
                        wiz.compile.error("what the hell. label was never given address!", decl.location, true);
                    }
                    if(addr != def.address) {
                        wiz.compile.error(
                            "what the hell. inconsistency in label positions detected"
                            + " (was " + addr + " on instruction selection pass, " + def.address + " on code-gen pass)",
                            decl.location, true
                        );
                    }
                }
            },

            Embed: function(stmt) {
                var description = "'embed' statement";
                var bank = program.checkBank(description, stmt.location);
                bank.writePhysical(stmt.data, stmt.location);
            },

            Data: function(stmt) {
                var description = "inline data";
                var result = {};
                if(wiz.compile.foldStorage(program, stmt.storage, result)) {
                    var data = [];
                    if(!stmt.items.length) {
                        throw new Error('no items in data statement');
                    }
                    for(var i = 0; i < stmt.items.length; i++) {
                        var item = stmt.items[i];
                        var bytes = wiz.compile.foldDataExpression(program, item, result.unit, program.finalized);
                        for(var j = 0; j < bytes.length; j++) {
                            data.push(bytes[j]);
                        }
                    }
                    if(!result.sizeless) {
                        if(data.length < result.value) {
                            // Fill unused section with final byte of data.
                            var pad = data[data.length - 1];
                            var k = result.value - data.length;
                            while(k > 0) {
                                data.push(pad);
                                k--;
                            }
                        } else if(data.length > result.value) {
                            wiz.compile.error(
                                description + " is an " + data.length + "-byte sequence, which is "
                                + (data.length - result.value) + " byte(s) over the declared "
                                + result.value + "-byte limit",
                                stmt.location
                            );
                        }
                    }
                    var bank = program.checkBank(description, stmt.location);
                    bank.writePhysical(data, stmt.location);
                }
            }
        });
        wiz.compile.verify();
    }

})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.compile = typeof(wiz.compile) !== 'undefined' ? wiz.compile : {};

    wiz.compile.Environment = function(parent) {
        var that = {};
        that.parent = parent || null;
        that.dictionary = {};

        that.printKeys = function() {
            for(key in that.dictionary) {
                wiz.compile.log(key + ': ' + that.dictionary[key]); 
            }
        };
        
        that.put = function(name, def) {
            var match = that.get(name, true);
            if(match) {
                wiz.compile.error("redefinition of symbol '" + name + "'", def.decl.location, false, true);
                wiz.compile.error("(previously defined here)", match.decl.location);
            } else {
                that.dictionary[name] = def;
            }
        };

        that.get = function(name, shallow) {
            shallow = shallow || false;
            var match = that.dictionary[name] || null;
            if(!match) {
                if(shallow || !parent) {
                    return null;
                } else {
                    return that.parent.get(name, shallow);
                }
            } else {
                while(wiz.sym.check('AliasDef', match)) {
                    match = match.definition;
                }
                return match;
            }
        }

        return that;
    };
})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.compile = typeof(wiz.compile) !== 'undefined' ? wiz.compile : {};

    wiz.compile.Location = function(file, line) {
        var that = {};
        that.file = file;
        that.line = line ? line : 0;

        that.copy = function() {
            return wiz.compile.Location(that.file, that.line);
        };
        
        that.toString = function() {
            return file + "(" + line + ")";
        };
        return that;
    };
})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.compile = typeof(wiz.compile) !== 'undefined' ? wiz.compile : {};

    function NodeScope(environment) {
        var that = {};
        that.environments = [environment];
        that.index = that.environments.length;

        that.rewind = function() {
            that.index = 0;
        }

        that.add = function(environment) {
            that.environments.push(environment);
            that.index = that.environments.length;
        }

        that.next = function() {
            if(that.index < that.environments.length) {
                return that.environments[that.index++];
            } else {
                return null;
            }
        }
        return that;
    }

    wiz.compile.Program = function(platform) {
        var that = {};
        that.bank = null;
        that.banks = [];

        that.scopes = {}; // ast.Node -> NodeScope;
        that.environment = null;
        that.environments = [];
        that.inlines = [];
        that.inlined = {} // ast.Node -> boolean
        that.finalized = false;
        that.platform = platform;

        that.rewind = function() {
            for(var k in that.scopes) {
                that.scopes[k].rewind();
            }
            for(var i = 0; i < that.banks.length; i++) {
                that.banks[i].rewind();
            }
            that.bank = null;
        }

        that.addBank = function(b) {
            that.banks.push(b);
        }

        that.checkBank = function(description, location) {
            if(!that.bank) {
                wiz.compile.error(description + " is not allowed before an 'in' statement.", location, true);
                return null;
            } else {
                return that.bank;
            }
        }

        that.switchBank = function(b) {
            that.bank = b;
        }

        that.clearEnvironment = function() {
            var builtins = platform.builtins();
            var env = wiz.compile.Environment();
            var pkg = wiz.sym.PackageDef(wiz.ast.BuiltinDecl(), wiz.compile.Environment(env));
            
            for(var name in builtins) {
                env.put(name, builtins[name]);
            }
            env.put("builtin", pkg);

            env = pkg.environment;
            for(var name in builtins) {
                env.put(name, builtins[name]);
            }

            that.environment = env;
            that.scopes = {};
            that.environments = [env];
        }

        that.createNodeEnvironment = function(node, environment) {
            var match = that.scopes[node.nodeId] || null;
            if(match) {
                match.add(environment);
            } else {
                that.scopes[node.nodeId] = NodeScope(environment);
            }
        }

        that.nextNodeEnvironment = function(node) {
            var match = that.scopes[node.nodeId] || null;
            if(match) {
                return match.next();
            } else {
                return null;
            }
        }

        that.enterEnvironment = function(e) {
            that.environments.push(e);
            that.environment = e;
        }

        that.leaveEnvironment = function() {
            that.environments.pop();
            if(that.environments.length > 0) {
                that.environment = that.environments[that.environments.length - 1];
            } else {
                throw new Error("stack underflow", that.environment);
            }
        }

        that.enterInline = function(context, node) {
            var match = that.inlined[node.nodeId] || false;
            if(match) {
                wiz.compile.error("recursive cycle detected in " + context + ":", node.location, false, true);
                for(var i = 0; i < that.inlines.length; i++) {
                    wiz.compile.log(that.inlines[i].location + " - stack entry #" + i);
                }
                wiz.compile.error("infinite recursion is unrecoverable", node.location, true);
                wiz.compile.abort();
            }

            that.inlined[node.nodeId] = true;
            that.inlines.push(node);
        }

        that.leaveInline = function() {
            that.inlined[that.inlines[that.inlines.length - 1].nodeId] = false;
            that.inlines.pop();
        }

        that.save = function() {
            var buffer = [];
            for(var i = 0; i < that.banks.length; i++) {
                that.banks[i].dump(buffer);
            }
            platform.patch(buffer);
            return new Uint8Array(buffer);
        }

        that.clearEnvironment();
        return that;
    }

})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.compile = typeof(wiz.compile) !== 'undefined' ? wiz.compile : {};

    wiz.compile.maximumErrors = 64;
    var errors;
    var previousContinued;

    wiz.compile.clearErrors = function() {
        errors = 0;
        previousContinued = false;
    }


    wiz.compile.clearLog = function() {}

    wiz.compile.CompileExit = function() {
        this.name = 'wiz.compile.CompileExit';
        this.message = 'Compile exit requested.';
    };

    function severity(fatal, previousContinued) {
        if(fatal) {
            return "fatal";
        } else if(previousContinued) {
            return "note";
        } else {
            return "error";
        }
    }

    wiz.compile.error = function(message, location, fatal, continued) {
        wiz.compile.log(location.toString(location) + ": " + severity(fatal, previousContinued) + ": " + message);
        if(!continued) {
            errors++;
        }
        previousContinued = continued;
        if(fatal || errors >= wiz.compile.maximumErrors) {
            wiz.compile.abort();
        }
    };

    wiz.compile.verify = function() {
        if(errors > 0) {
            wiz.compile.abort();
        }
    };

    wiz.compile.log = function(message) {
        console.log(message);
    };

    wiz.compile.notice = function(message) {
        wiz.compile.log("* wiz: " + message);
    };

    wiz.compile.abort = function() {
        wiz.compile.notice("failed with " + errors + " error(s)");
        throw new wiz.compile.CompileExit();
    };
})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.compile = typeof(wiz.compile) !== 'undefined' ? wiz.compile : {};

    wiz.compile.Visitor = function(callbacks) {
        var that = {};
        that.pre = {}
        that.post = {}
        for(var nodeType in callbacks) {
            var callback = callbacks[nodeType];

            if(typeof(callback) === 'function') {
                that.post[nodeType] = callback;
            } else {
                that.pre[nodeType] = callback.pre;
                that.post[nodeType] = callback.post;
            }
        }

        function visit(table, o) {
            if(typeof(o.nodeType) === 'undefined') {
                throw new Error('node missing node type');
            }

            var f = table[o.nodeType];
            if(!f) {
                return true;
            }
            return f(o);
        }

        that.preVisit = function(o) {
            return visit(that.pre, o);
        }

        that.postVisit = function(o) {
            return visit(that.post, o);
        }

        return that;
    };

    wiz.compile.traverse = function(node, callbacks) {
        wiz.compile.accept(node, wiz.compile.Visitor(callbacks));
    }

    wiz.compile.accept = function(node, visitor) {
        if(visitor.preVisit(node) !== false) {
            var children = node.nodeChildren;
            if(children) {
                for(var c = 0, clen = children.length; c < clen; c++) {
                    var child = node[children[c]];
                    if(child) {
                        if(typeof(child.length) !== 'undefined') {
                            for(var i = 0, ilen = child.length; i < ilen; i++) {
                                if(child[i]) {
                                    wiz.compile.accept(child[i], visitor);
                                }
                            }
                        } else {
                            wiz.compile.accept(child, visitor);
                        }
                    }
                }
            }
        }
        visitor.postVisit(node);
    }


})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.fs = typeof(wiz.fs) !== 'undefined' ? wiz.fs : {};

    wiz.fs.AbstractFile = function() {
        var that = {};
        that.calculateSize = function() { throw new Error('not implemented'); }
        that.readLines = function() { throw new Error('not implemented'); }
        that.readBinary = function() { throw new Error('not implemented'); }
        return that;
    }

    wiz.fs.MemoryFile = function(source) {
        var that = wiz.fs.AbstractFile();
        that.source = source;

        that.calculateSize = function() {
            return that.source.length;
        }

        that.readLines = function() {
            var lines = that.source.split(/\r?\n/);
            for(var i = 0; i < lines.length; i++) {
                lines[i] = lines[i] + '\n';
            }
            return lines;
        }
        return that;
    }

    wiz.fs.open = function(filename) {
        throw new Error('not implemented');
    }

    wiz.fs.reset = function() {
        // Free any open file handles and start fresh.
    }
})(this);(function(globals) {    
'use strict';
var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
wiz.parse = typeof(wiz.parse) !== 'undefined' ? wiz.parse : {};

wiz.parse.Parser = function(scanner) {
    var that = {};
    that.scanner = scanner;
    that.includes = [];
    that.included = {};
    that.included[scanner.getLocation().file] = true;
    that.token = wiz.parse.Token.None;
    that.text = "";
    that.keyword = wiz.parse.Keyword.None;

    that.nextToken = function() {
        that.token = that.scanner.next();
        that.text = that.scanner.consumeLastText();
        that.keyword = wiz.parse.Keyword.None;
        if(that.token == wiz.parse.Token.Identifier) {
            that.keyword = wiz.parse.findKeyword(that.text);
        }
    };

    that.reject = function(token, text, expectation, advance) {
        expectation = expectation || null;
        advance = typeof(advance) !== null ? advance : true;
        if(expectation === null) {
            wiz.compile.error("unexpected " + wiz.parse.getVerboseTokenName(token, text), that.scanner.getLocation());
        } else {
            wiz.compile.error("expected " + expectation + ", but got " + wiz.parse.getVerboseTokenName(token, text) + " instead", that.scanner.getLocation());
        }
        if(advance) {
            that.nextToken();
        }
    };

    that.consume = function(expected) {
        if(that.token == expected) {
            that.nextToken();
            return true;
        } else {
            that.reject(that.token, that.text, wiz.parse.getSimpleTokenName(expected));
            return false;
        }     
    };

    that.checkIdentifier = function(permissibleKeywords) {
        if(that.token == wiz.parse.Token.Identifier) {
            if(that.keyword == wiz.parse.Keyword.None) {
                return true;
            }
            if(permissibleKeywords) {
                var i;
                for(i = 0; i < permissibleKeywords.length; i++) {
                    if(permissibleKeywords[i] === that.keyword) {
                        return true;
                    }
                }

                var keywordNames = [];
                for(i = 0; i < permissibleKeywords.length; i++) {
                    keywordNames.push("keyword '" + wiz.parse.getKeywordName(permissibleKeywords[i]) + "'");
                }
                keywordNames[keywordNames.length - 1] = "or " + keywordNames[keywordNames.length - 1];
                
                wiz.compile.error("expected identifier, " + keywordNames.join(", ") + ", but got " + wiz.parse.getVerboseTokenName(that.token, that.text) + " instead", that.scanner.getLocation());
                return false;
            }
        }
        wiz.compile.error("expected identifier, but got " + wiz.parse.getVerboseTokenName(that.token, that.text) + " instead", that.scanner.getLocation());
        return false;
    };
    
    that.parse = function() {
        that.nextToken();
        var program = that.parseProgram();
        wiz.compile.verify();
        return program;
    };
    
    that.handleEndOfFile = function() {
        if(that.token == wiz.parse.Token.EndOfFile) {
            if(that.includes.length === 0) {
                return true;
            } else {
                // Remove include guard.
                that.included.remove(that.scanner.getLocation().file);
                // Pop previous scanner off stack.
                var old = that.scanner;
                that.scanner = that.includes.pop();
                // Ready a new token for the scanner.
                that.nextToken();
                return false;
            }
        }
        return false;
    };

    that.parseProgram = function() {
        // program = (include | statement)* EOF
        var location = that.scanner.getLocation();
        var statements = [];
        while(true) {
            if(that.handleEndOfFile()) {
                break;
            }
            if(that.token == wiz.parse.Token.EndOfFile) {
                continue;
            }
            if(that.keyword == wiz.parse.Keyword.End || that.keyword == wiz.parse.Keyword.Else || that.keyword == wiz.parse.Keyword.ElseIf) {
                that.reject(that.token, that.text);
            }
            var statement = that.parseStatement();
            if(statement) {
                statements.push(statement);
            }
        }
        return wiz.ast.Block(null, statements, location);
    };
    
    that.parseCompound = function() {
        // compound = statement* 'end'
        var statements = [];
        while(true) {
            if(that.handleEndOfFile()) {
                that.reject(that.token, that.text, "'end'");
                return null;
            }
            if(that.keyword == wiz.parse.Keyword.End) {
                return statements;
            }
            if(that.keyword == wiz.parse.Keyword.Else || that.keyword == wiz.parse.Keyword.ElseIf) {
                that.reject(that.token, that.text, "'end'");
            }
            var statement = that.parseStatement();
            if(statement) {
                statements.push(statement);
            }
        }
    };

    that.parseConditionalPrelude = function() {
        // preconditional_compound = statement* 'is'
        var statements = [];
        while(true) {
            if(that.handleEndOfFile()) {
                that.reject(that.token, that.text, "'is'");
                return null;
            }
            if(that.keyword == wiz.parse.Keyword.Is) {
                return statements;
            }
            if(that.keyword == wiz.parse.Keyword.End || that.keyword == wiz.parse.Keyword.Else || that.keyword == wiz.parse.Keyword.ElseIf) {
                that.reject(that.token, that.text, "'is'");
            }
            var statement = that.parseStatement();
            if(statement) {
                statements.push(statement);
            }
        }
    };
    
    that.parseConditionalBlock = function() {
        // conditional_compound = statement* ('else' | 'elseif' | 'end')
        var statements = [];
        while(true) {
            if(that.handleEndOfFile()) {
                that.reject(that.token, that.text, "'end'");
                return null;
            }
            if(that.keyword == wiz.parse.Keyword.End || that.keyword == wiz.parse.Keyword.Else || that.keyword == wiz.parse.Keyword.ElseIf) {
                return statements;
            }
            var statement = that.parseStatement();
            if(statement) {
                statements.push(statement);
            }
        }
    };

    that.parseStatement = function() {
        // statement =
        //      embed
        //      | relocation
        //      | block
        //      | bank
        //      | label
        //      | let
        //      | var
        //      | func
        //      | inline
        //      | data
        //      | jump
        //      | conditional
        //      | loop
        //      | comparison
        //      | command
        //      | assignment
        switch(that.token) {
            case wiz.parse.Token.Identifier:
                switch(that.keyword) {
                    case wiz.parse.Keyword.Include:
                        that.parseInclude();
                        return null;
                    case wiz.parse.Keyword.Embed:
                        return that.parseEmbed();
                    case wiz.parse.Keyword.In:
                        return that.parseRelocation();
                    case wiz.parse.Keyword.Do: case wiz.parse.Keyword.Package:
                        return that.parseBlock();
                    case wiz.parse.Keyword.Bank:
                        return that.parseBankDecl();
                    case wiz.parse.Keyword.Def:
                        return that.parseLabelDecl();
                    case wiz.parse.Keyword.Let:
                        return that.parseLetDecl();
                    case wiz.parse.Keyword.Var:
                        return that.parseVarDecl();
                    case wiz.parse.Keyword.Func: case wiz.parse.Keyword.Task:
                        return that.parseFuncDecl();
                    case wiz.parse.Keyword.Inline:
                        return that.parseInline();
                    case wiz.parse.Keyword.Byte: case wiz.parse.Keyword.Word:
                        return that.parseData();
                    case wiz.parse.Keyword.Goto: case wiz.parse.Keyword.Call:
                    case wiz.parse.Keyword.Return: case wiz.parse.Keyword.Resume:
                    case wiz.parse.Keyword.Break: case wiz.parse.Keyword.Continue:
                    case wiz.parse.Keyword.While: case wiz.parse.Keyword.Until:
                    case wiz.parse.Keyword.Abort: case wiz.parse.Keyword.Sleep: case wiz.parse.Keyword.Suspend: case wiz.parse.Keyword.Nop:
                        return that.parseJump();
                    case wiz.parse.Keyword.If:
                        return that.parseConditional();
                    case wiz.parse.Keyword.Loop:
                        return that.parseLoop();
                    case wiz.parse.Keyword.Unroll:
                        return that.parseUnroll();
                    case wiz.parse.Keyword.Compare:
                        return that.parseComparison();
                    case wiz.parse.Keyword.Push:
                        return that.parsePush();
                    case wiz.parse.Keyword.None:
                        // Some unreserved identifier. Try and parse as a term in an assignment!
                        return that.parseAssignment();
                    default:
                        that.reject(that.token, that.text, "statement");
                        break;
                }
                break;
            case wiz.parse.Token.Integer:
            case wiz.parse.Token.Hexadecimal:
            case wiz.parse.Token.Binary:
            case wiz.parse.Token.String:
            case wiz.parse.Token.LParen:
                that.reject(that.token, that.text, "statement", false);
                that.skipAssignment(true);
                break;
            case wiz.parse.Token.Set:
                that.reject(that.token, that.text, "statement", false);
                that.skipAssignment(false);
                break;
            case wiz.parse.Token.LBracket:
                return that.parseAssignment();
            case wiz.parse.Token.Semi:
                // semi-colon, skip.
                that.nextToken();
                break;
            default:
                that.reject(that.token, that.text, "statement");
                break;
        }
        return null;
    };
        
    that.parseInclude = function() {
        // include = 'include' STRING
        that.nextToken(); // IDENTIFIER (keyword 'include')
        
        var filename = null;
        if(that.token == wiz.parse.Token.String) {
            // Don't call nextToken() here, we'll be doing that when the scanner's popped off later.
            filename = that.text;
        } else {
            that.consume(wiz.parse.Token.String);
            return;
        }
        
        // Make the filename relative to its current source.
        //filename = std.path.dirName(scanner.getLocation().file) ~ std.path.dirSeparator ~ filename;

        function isEmpty(obj) {
            for(var key in obj) {
                if(obj.hasOwnProperty(key))
                    return false;
            }
            return true;
        }

        // Make sure the start path is included in the list of included filenames.
        if(isEmpty(that.included)) {
            var cur = that.scanner.getLocation().file;
            //included[std.path.dirName(cur) ~ std.path.dirSeparator ~ cur] = true;
            that.included[cur] = true;
        }
        // Already included. Skip!
        if(that.included[filename]) {
            that.nextToken(); // STRING
            return;
        }
        
        // Push old scanner onto stack.
        that.includes.push(that.scanner);
        // Add include guard.
        that.included[filename] = true;
        
        // Open the new file.
        var file = wiz.fs.open(filename);
        if(file) {
            // Swap scanner.
            that.scanner = wiz.parse.Scanner(file, filename);
        } else {
            wiz.compile.error("could not include file '" + filename + "'", that.scanner.getLocation(), true);
        }
        // Now, ready the first token of the file.
        that.nextToken();
    };
    
    that.parseEmbed = function() {
        // embed = 'embed' STRING
        var location = that.scanner.getLocation();
        that.nextToken(); // IDENTIFIER (keyword 'embed')
        
        if(that.token == wiz.parse.Token.String) {
            var filename = that.text;
            that.nextToken(); // STRING
            
            // Make the filename relative to its current source.
            //filename = std.path.dirName(scanner.getLocation().file) ~ std.path.dirSeparator ~ filename;
            return wiz.ast.Embed(filename, location);
        } else {
            that.consume(wiz.parse.Token.String);
            return null;
        }
    };
    
    that.parseRelocation = function() {
        // relocation = 'in' IDENTIFIER (',' expression)? ':'
        var location = that.scanner.getLocation();
        var name;
        var dest;
        
        that.nextToken(); // IDENTIFIER (keyword 'in')
        if(that.checkIdentifier()) {
            name = that.text;
        }
        that.nextToken(); // IDENTIFIER
        // (, expr)?
        if(that.token == wiz.parse.Token.Comma) {
            that.nextToken(); // ,
            dest = that.parseExpression(); // expression
        }
        that.consume(wiz.parse.Token.Colon); // :
        
        return wiz.ast.Relocation(name, dest, location);
    };
    
    that.parseBlock = function() {
        // block = ('package' IDENTIFIER | 'do') statement* 'end'
        var location = that.scanner.getLocation();
        var statements;
        switch(that.keyword) {
            case wiz.parse.Keyword.Do:
                that.nextToken(); // IDENTIFIER (keyword 'do')
                statements = that.parseCompound(); // compound statement
                that.nextToken(); // IDENTIFIER (keyword 'end')
                return wiz.ast.Block(null, statements, location);
            case wiz.parse.Keyword.Package:
                var name;
                
                that.nextToken(); // IDENTIFIER (keyword 'package')
                if(that.checkIdentifier()) {
                    name = that.text;
                }
                that.nextToken(); // IDENTIFIER
                if(that.keyword == wiz.parse.Keyword.Do) {
                    that.nextToken(); // IDENTIFIER (keyword 'do')
                } else {
                    that.reject(that.token, that.text, "'do'");
                }

                statements = that.parseCompound(); // compound statement
                that.nextToken(); // IDENTIFIER (keyword 'end')
                return wiz.ast.Block(name, statements, location);
            default:
                throw new Error("unexpected compilation error: incorrectly classified token as start of block statement");
        }
    };
    
    that.parseBankDecl = function() {
        // bank = 'bank' IDENTIFIER (',' IDENTIFIER)* ':' IDENTIFIER '*' expression
        var location = that.scanner.getLocation();
        
        var names = [];
        var type = null;
        var size = null;
        
        that.nextToken(); // IDENTIFIER (keyword 'bank')
        
        if(that.checkIdentifier()) {
            names.push(that.text);
        }
        that.nextToken(); // IDENTIFIER
        
        // Check if we should match (',' id)*
        while(that.token == wiz.parse.Token.Comma) {
            that.nextToken(); // ,
            if(that.token == wiz.parse.Token.Identifier) {
                if(that.checkIdentifier()) {
                    // parse name
                    names.push(that.text);
                }
                that.nextToken(); // IDENTIFIER
            } else {
                that.reject(that.token, that.text, "identifier after ',' in bank declaration");
                break;
            }
        }
        
        that.consume(wiz.parse.Token.Colon); // :
        
        if(that.checkIdentifier()) {
            type = that.text;
        }
        that.nextToken(); // IDENTIFIER (bank type)
        that.consume(wiz.parse.Token.Mul); // *
        size = that.parseExpression(); // term
        
        return wiz.ast.BankDecl(names, type, size, location);
    };
    
    that.parseLabelDecl = function () {
        // label = 'def' IDENTIFIER ':'
        var location = that.scanner.getLocation();
        
        var name;
        
        that.nextToken(); // IDENTIFIER (keyword 'def')
        if(that.checkIdentifier()) {
            name = that.text;
        }
        that.nextToken(); // IDENTIFIER
        that.consume(wiz.parse.Token.Colon);
        
        return wiz.ast.LabelDecl(name, location);
    };

    that.parseStorage = function() {
        // storage = ('byte' | 'word') ('*' expression)?
        var location = that.scanner.getLocation();
        if(that.checkIdentifier([wiz.parse.Keyword.Byte, wiz.parse.Keyword.Word])) {
            var storageType;
            switch(that.keyword) {
                case wiz.parse.Keyword.Byte:
                case wiz.parse.Keyword.Word:
                    storageType = that.keyword;
                    break;
                default:
                    wiz.compile.error("invalid type specifier '" + that.text + "'. only 'byte' and 'word' are allowed.", scanner.getLocation());
            }
            that.nextToken(); // IDENTIFIER (keyword 'byte'/'word')
            // ('*' array_size)?
            var arraySize = null;
            if(that.token == wiz.parse.Token.Mul) {
                that.nextToken(); // *
                arraySize = that.parseExpression(); // expression
            } 
            return wiz.ast.Storage(storageType, arraySize, location);
        } else {
            that.reject(that.token, that.text, "type specifier");
            return null;
        }
    };
    
    that.parseLetDecl = function() {
        // let = 'let' IDENTIFIER '=' expression
        var location = that.scanner.getLocation();
        
        var name;
        var value;
        
        that.nextToken(); // IDENTIFIER (keyword 'let')
        if(that.checkIdentifier()) {
            name = that.text;
        }
        that.nextToken(); // IDENTIFIER
        that.consume(wiz.parse.Token.Set); // =
        value = that.parseExpression(); // expression
        return wiz.ast.LetDecl(name, value, 0, location);
    };
    
    that.parseVarDecl = function() {
        // var = 'var' IDENTIFIER (',' IDENTIFIER)*
        //      ':' ('byte' | 'word') '*' expression
        var location = that.scanner.getLocation();
        
        var names = [];
        that.nextToken(); // IDENTIFIER (keyword 'var')
        
        if(that.checkIdentifier()) {
            names.push(that.text);
        }
        that.nextToken(); // IDENTIFIER
        
        // Check if we should match (',' id)*
        while(that.token == wiz.parse.Token.Comma) {
            that.nextToken(); // ,
            if(that.token == wiz.parse.Token.Identifier) {
                if(that.checkIdentifier()) {
                    // parse name
                    names.push(that.text);
                }
                that.nextToken(); // IDENTIFIER
            } else {
                that.reject(that.token, that.text, "identifier after ',' in variable declaration");
                break;
            }
        }
        
        that.consume(wiz.parse.Token.Colon); // :
        var storage = that.parseStorage();
        return wiz.ast.VarDecl(names, storage, location);
    };

    that.parseFuncDecl = function() {
        // func = 'func' IDENTIFIER 'do' statement* 'end'
        var location = that.scanner.getLocation();

        var name;
        var type = that.keyword;

        that.nextToken(); // IDENTIFIER (keyword 'func')

        if(that.checkIdentifier()) {
            name = that.text;
        }
        that.nextToken(); // IDENTIFIER

        if(that.keyword == wiz.parse.Keyword.Do) {
            that.nextToken(); // IDENTIFIER (keyword 'do')
        } else {
            that.reject(that.token, that.text, "'do'");
        }
        var block = wiz.ast.Block(null, that.parseCompound(), location); // statement*
        that.nextToken(); // IDENTIFIER (keyword 'end')

        return wiz.ast.FuncDecl(type, name, block, location);   
    };

    that.parseInline = function() {
        // inline = 'inline' func | call
        var location = that.scanner.getLocation();

        var func;

        that.nextToken(); // IDENTIFIER (keyword 'inline')
        if(that.keyword == wiz.parse.Keyword.Func) {
            func = that.parseFuncDecl();
            func.inlined = true;
            return func;
        } else if(that.keyword == wiz.parse.Keyword.Task) {
            func = that.parseFuncDecl();
            wiz.compile.error("'inline task' is not a valid construct, try 'inline func' instead.", location);
            return null;
        } else if(that.keyword == wiz.parse.Keyword.Call) {
            var far = false;
            that.nextToken(); // IDENTIFIER (keyword 'call')
            if(that.token == wiz.parse.Token.Exclaim) {
                that.nextToken(); // '!'
                far = true;
            }
            var destination = that.parseExpression();
            var condition = null;
            if(that.token == wiz.parse.Token.Identifier && that.keyword == wiz.parse.Keyword.When) {
                that.nextToken(); // IDENTIFIER (keyword 'when')
                condition = that.parseJumpCondition("'when'");
            }
            return wiz.ast.Jump(wiz.parse.Keyword.Inline, far, destination, condition, location);
        } else {
            that.reject(that.token, that.text, "'func'");
            return null;
        }
    };
    
    that.parseData = function() {
        // data = ('byte' | 'word') data_item (',' data_item)*
        //      where data_item = expression | STRING
        var location = that.scanner.getLocation();
        var storage = that.parseStorage();
        that.consume(wiz.parse.Token.Colon); // :
        
        var items = [];

        // item (',' item)*
        while(true) {
            var expr = that.parseExpression(); // expression
            items.push(expr);
            // (',' item)*
            if(that.token == wiz.parse.Token.Comma) {
                that.nextToken(); // ,
                continue;
            }
            break;
        }
        return wiz.ast.Data(storage, items, location);
    };
    
    that.parseJump = function() {
        // jump = 'goto' expression ('when' jump_condition)?
        //      | 'call' expression ('when' jump_condition)?
        //      | 'return' ('when' jump_condition)?
        //      | 'resume' ('when' jump_condition)?
        //      | 'break' ('when' jump_condition)?
        //      | 'continue' ('when' jump_condition)?
        //      | 'while' jump_condition
        //      | 'until' jump_condition
        //      | 'abort'
        //      | 'sleep'
        //      | 'suspend'
        //      | 'nop'
        var location = scanner.getLocation();

        var type = that.keyword;
        var far = false;
        that.nextToken(); // IDENTIFIER (keyword)
        if(that.token == wiz.parse.Token.Exclaim) {
            that.nextToken(); // '!'
            far = true;
        }
        var condition;
        switch(type) {
            case wiz.parse.Keyword.Goto: case wiz.parse.Keyword.Call:
                var destination = that.parseExpression();
                condition = null;
                if(that.token == wiz.parse.Token.Identifier && that.keyword == wiz.parse.Keyword.When) {
                    that.nextToken(); // IDENTIFIER (keyword 'when')
                    condition = that.parseJumpCondition("'when'");
                }
                return wiz.ast.Jump(type, far, destination, condition, location);
            case wiz.parse.Keyword.Return:
            case wiz.parse.Keyword.Resume:
            case wiz.parse.Keyword.Break:
            case wiz.parse.Keyword.Continue:
                condition = null;
                if(that.token == wiz.parse.Token.Identifier && that.keyword == wiz.parse.Keyword.When) {
                    that.nextToken(); // IDENTIFIER (keyword 'when')
                    condition = that.parseJumpCondition("'when'");
                }
                return wiz.ast.Jump(type, far, null, condition, location);
            case wiz.parse.Keyword.While:
                return wiz.ast.Jump(type, far, null, that.parseJumpCondition("'while'"), location);
            case wiz.parse.Keyword.Until:
                return wiz.ast.Jump(type, far, null, that.parseJumpCondition("'until'"), location);
            default:
                return wiz.ast.Jump(type, far, null, null, location);
        }
    };
    
    that.parseJumpCondition = function(context) {
        // jump_condition = '~'* (IDENTIFIER | '~=' | '==' | '<' | '>' | '<=' | '>=')

        // '~'*
        var negated = false;
        while(that.token == wiz.parse.Token.Not) {
            that.nextToken(); // '~'
            negated = !negated;
            context = "'~'";
        }
        
        switch(that.token) {
            case wiz.parse.Token.Identifier:
                var attr = that.parseAttribute();
                return wiz.ast.JumpCondition(negated, attr, scanner.getLocation());
            case wiz.parse.Token.NotEqual:
            case wiz.parse.Token.Equal:
            case wiz.parse.Token.Less:
            case wiz.parse.Token.Greater:
            case wiz.parse.Token.LessEqual:
            case wiz.parse.Token.GreaterEqual:
                var type = that.token;
                that.nextToken(); // operator token
                return wiz.ast.JumpCondition(negated, type, scanner.getLocation());
            default:
                that.reject(that.token, that.text, "condition after " + context);
                return null;
        }        
    };
    
    that.parseConditional = function() {
        // condition = 'if' statement* 'is' condition 'then' statement*
        //      ('elseif' statement* 'is' condition 'then' statement*)*
        //      ('else' statement)? 'end'
        var first = null;
        var statement = null;
        var location;

        // 'if' condition 'then' statement* ('elseif' condition 'then' statement*)*
        do {
            location = that.scanner.getLocation();
            that.nextToken(); // IDENTIFIER (keyword 'if' / 'elseif')
            
            var far = false;
            if(that.token == wiz.parse.Token.Exclaim) {
                that.nextToken(); // '!'
                far = true;
            }
            
            var prelude = wiz.ast.Block(null, that.parseConditionalPrelude(), location); // statement*

            if(that.keyword == wiz.parse.Keyword.Is) {
                that.nextToken(); // IDENTIFIER (keyword 'is')
            } else {
                that.reject(that.token, that.text, "'is'");
            }

            var condition = that.parseJumpCondition("'is'"); // condition
            
            if(that.keyword == wiz.parse.Keyword.Then) {
                that.nextToken(); // IDENTIFIER (keyword 'then')
            } else {
                that.reject(that.token, that.text, "'then'");
            }
            
            var block = wiz.ast.Block(null, that.parseConditionalBlock(), location); // statement*
            
            // Construct if statement/
            var previous = statement;
            statement = wiz.ast.Conditional(condition, far, prelude, block, location);

            // If this is an 'elseif', join to previous 'if'/'elseif'.
            if(previous) {
                previous.alternative = statement;
            } else if(first === null) {
                first = statement;
            }
        } while(that.keyword == wiz.parse.Keyword.ElseIf);
        
        // ('else' statement*)? 'end' (with error recovery for an invalid trailing else/elseif placement)
        if(that.keyword == wiz.parse.Keyword.Else) {
            location = that.scanner.getLocation();
            that.nextToken(); // IDENTIFIER (keyword 'else')
            statement.alternative = wiz.ast.Block(null, that.parseConditionalBlock(), location); // statement*
        }
        switch(that.keyword) {
            case wiz.parse.Keyword.Else:
                wiz.compile.error("duplicate 'else' clause found.", that.scanner.getLocation());
                break;
            case wiz.parse.Keyword.ElseIf:
                // Seeing as we loop on elseif before an else/end, this must be an illegal use of elseif.
                wiz.compile.error("'elseif' can't appear after 'else' clause.", that.scanner.getLocation());
                break;
            default:
        }

        if(that.keyword == wiz.parse.Keyword.End) {
            that.nextToken(); // IDENTIFIER (keyword 'end')
        }
        else {
            that.reject(that.token, that.text, "'end'");
        }
        return first;
    };
    
    that.parseLoop = function() {
        // loop = 'loop' statement* 'end'
        var location = that.scanner.getLocation();
        that.nextToken(); // IDENTIFIER (keyword 'loop')
        var far = false;
        if(that.token == wiz.parse.Token.Exclaim)
        {
            that.nextToken(); // '!'
            far = true;
        }
        var block = wiz.ast.Block(null, that.parseCompound(), location); // statement*
        that.nextToken(); // IDENTIFIER (keyword 'end')
        return wiz.ast.Loop(block, far, location);
    };

    that.parseUnroll = function() {
        // unroll = 'unroll' '*' expression ':' statement
        var location = that.scanner.getLocation();
        that.nextToken(); // IDENTIFIER (keyword 'unroll')
        var repetitions = that.parseExpression();

        if(that.keyword == wiz.parse.Keyword.Do) {
            that.nextToken(); // IDENTIFIER (keyword 'do')
        } else {
            that.reject(that.token, that.text, "'do'");
        }
        var block = wiz.ast.Block(null, that.parseCompound(), location); // statement*
        that.nextToken(); // IDENTIFIER (keyword 'end')

        return wiz.ast.Unroll(repetitions, block, location);
    };

    that.parseComparison = function() {
        // comparison = 'compare' expression ('to' expression)?
        var location = that.scanner.getLocation();
        that.nextToken(); // IDENTIFIER (keyword 'compare')
        var term = that.parseExpression();
        if(that.keyword == wiz.parse.Keyword.To) {
            that.nextToken(); // IDENTIFIER (keyword 'to')
            var other = that.parseExpression();
            return wiz.ast.Comparison(term, other, location);
        } else {
            return wiz.ast.Comparison(term, location);
        }
    };

    that.parsePush = function() {
        // command = command_token expression
        var location = that.scanner.getLocation();
        var command = that.keyword;
        that.nextToken(); // IDENTIFIER (keyword)
        var argument = that.parseExpression();
        if(that.token == wiz.parse.Token.Identifier && that.keyword == wiz.parse.Keyword.Via) {
            that.nextToken(); // IDENTIFIER (keyword 'via')
            var intermediary = that.parseTerm(); // term
            return wiz.ast.Push(argument, intermediary, location);
        }
        return wiz.ast.Push(argument, null, location);
    };

    that.skipAssignment = function(leadingExpression) {
        // Some janky error recovery. Gobble an expression.
        if(leadingExpression) {
            that.parseExpression(); // expr
        }
        // If the expression is followed by an assignment, then gobble the assignment.
        if(that.token == wiz.parse.Token.Set) {
            that.nextToken(); // =
            // If the thing after the = is an expression, then gobble that too.
            switch(that.token) {
                case wiz.parse.Token.Integer:
                case wiz.parse.Token.Hexadecimal:
                case wiz.parse.Token.Binary:
                case wiz.parse.Token.String:
                case wiz.parse.Token.LParen:
                    that.parseExpression();
                    break;
                case wiz.parse.Token.Identifier:
                    if(that.keyword == wiz.parse.Keyword.None || that.keyword == wiz.parse.Keyword.Pop) {
                        that.parseExpression();
                    }
                    break;
                default:
            }
        }
    };

    that.parseAssignment = function() {
        // assignment = assignable_term ('=' expression ('via' term)? | postfix_token)
        var location = that.scanner.getLocation();
        var dest = that.parseAssignableTerm(); // term
        var op = that.token;
        var opText = that.text;
        if(that.token == wiz.parse.Token.Set) {
            that.nextToken(); // =
            var src = that.parseExpression(); // expression
            if(that.token == wiz.parse.Token.Identifier && that.keyword == wiz.parse.Keyword.Via) {
                that.nextToken(); // IDENTIFIER (keyword 'via')
                var intermediary = that.parseTerm(); // term
                return wiz.ast.Assignment(dest, intermediary, src, null, location);
            } else {
                return wiz.ast.Assignment(dest, null, src, null, location);
            }
        } else if(that.isPostfixToken()) {
            that.nextToken(); // postfix_token
            return wiz.ast.Assignment(dest, null, null, op, location);
        } else {
            if(that.token == wiz.parse.Token.Identifier || that.token == wiz.parse.Token.Integer || that.token == wiz.parse.Token.Hexadecimal || that.token == wiz.parse.Token.Binary) {
                that.reject(op, opText, "statement", false);
            } else {
                that.reject(that.token, that.text, "an assignment operator like '=', '++', or '--'");
            }
            that.skipAssignment(true);
            return null;
        }
    };

    that.parseExpression = function() {
        // expression = infix
        return that.parseInfix();
    };

    that.isInfixToken = function() {
        // infix_token = ...
        switch(that.token) {
            case wiz.parse.Token.At:
            case wiz.parse.Token.Add:
            case wiz.parse.Token.Sub:
            case wiz.parse.Token.Mul:
            case wiz.parse.Token.Div:
            case wiz.parse.Token.Mod:
            case wiz.parse.Token.AddC:
            case wiz.parse.Token.SubC:
            case wiz.parse.Token.ShiftL:
            case wiz.parse.Token.ShiftR:
            case wiz.parse.Token.ArithShiftL:
            case wiz.parse.Token.ArithShiftR:
            case wiz.parse.Token.RotateL:
            case wiz.parse.Token.RotateR:
            case wiz.parse.Token.RotateLC:
            case wiz.parse.Token.RotateRC:
            case wiz.parse.Token.Or:
            case wiz.parse.Token.And:
            case wiz.parse.Token.Xor:
                return true;
            default:
                return false;
        }
    };

    that.isPrefixToken = function() {
        // prefix_token = ...
        switch(that.token) {
            case wiz.parse.Token.Less:
            case wiz.parse.Token.Greater:
            case wiz.parse.Token.Swap:
            case wiz.parse.Token.Sub:
            case wiz.parse.Token.Not:
                return true;
            default:
                return false;
        }
    };

    that.isPostfixToken = function() {
        // postfix_token = ...
        switch(that.token) {
            case wiz.parse.Token.Inc:
            case wiz.parse.Token.Dec:
                return true;
            default:
                return false;
        }
    };

    that.parseInfix = function() {
        // infix = postfix (infix_token postfix)*
        var location = that.scanner.getLocation();
        var types = [];
        var operands = [];

        operands.push(that.parsePrefix()); // postfix
        while(true) {
            if(that.isInfixToken()) {
                types.push(that.token);
                that.nextToken(); // operator token
                operands.push(that.parsePrefix()); // postfix
            } else {
                if(operands.length > 1) {
                    return wiz.ast.Infix(types, operands, location);
                } else {
                    return operands[0];
                }
            }
        }
    };

    that.parsePrefix = function() {
        // prefix = prefix_token prefix | postfix
        if(that.isPrefixToken()) {
            var location = that.scanner.getLocation();
            var op = that.token;
            that.nextToken(); // operator token
            var expr = that.parsePrefix(); // prefix
            return wiz.ast.Prefix(op, expr, location);
        } else {
            return that.parsePostfix(); // postfix
        }
    };

    that.parsePostfix = function() {
        // postfix = term postfix_token*
        var expr = that.parseTerm(); // term
        while(true) {
            if(that.isPostfixToken()) {
                var op = that.token;
                expr = wiz.ast.Postfix(op, expr, that.scanner.getLocation());
                that.nextToken(); // operator token
            } else {
                return expr;
            }
        }
    };

    that.parseAssignableTerm = function() {
        // assignable_term = term ('@' term)?
        var location = that.scanner.getLocation();
        var expr = that.parseTerm();
        if(that.token == wiz.parse.Token.At) {
            that.nextToken(); // '@'
            return wiz.ast.Infix(wiz.parse.Infix.At, expr, that.parseTerm(), location);
        } else {
            return expr;
        }
    };

    that.parseTerm = function() {
        // term = INTEGER
        //      | HEXADECIMAL
        //      | LPAREN expression RPAREN
        //      | LBRACKET expression RBRACKET
        //      | IDENTIFIER ('.' IDENTIFIER)*
        //      | 'pop'
        var location = that.scanner.getLocation();
        var expr;
        switch(that.token) {
            case wiz.parse.Token.Integer:
                return that.parseNumber(10);
            case wiz.parse.Token.Hexadecimal:
                return that.parseNumber(16);
            case wiz.parse.Token.Binary:
                return that.parseNumber(2);
            case wiz.parse.Token.String:
                expr = wiz.ast.String(that.text, location);
                that.nextToken(); // STRING
                return expr;
            case wiz.parse.Token.LParen:
                that.nextToken(); // (
                expr = that.parseExpression(); // expression 
                that.consume(wiz.parse.Token.RParen); // )
                return wiz.ast.Prefix(wiz.parse.Prefix.Grouping, expr, location);
            case wiz.parse.Token.LBracket:
                that.nextToken(); // [
                expr = that.parseExpression(); // expression
                
                if(that.token == wiz.parse.Token.Colon)
                {
                    that.nextToken(); // :
                    var index = that.parseExpression(); // expression
                    expr = wiz.ast.Infix(wiz.parse.Infix.Colon, expr, index, location);
                }
                that.consume(wiz.parse.Token.RBracket); // ]
                return wiz.ast.Prefix(wiz.parse.Prefix.Indirection, expr, location);
            case wiz.parse.Token.Identifier:
                if(that.keyword == wiz.parse.Keyword.Pop) {
                    that.nextToken(); // IDENTIFIER
                    return wiz.ast.Pop(location);
                }
                return that.parseAttribute();
            default:
                that.reject(that.token, that.text, "expression");
                return null;
        }
    };

    that.parseNumber = function(radix) {
        // number = INTEGER | HEXADECIMAL | BINARY
        var location = that.scanner.getLocation();
        var numberToken = that.token;
        var numberText = that.text;
        that.nextToken(); // number

        var t = numberText;
        // prefix?
        if(radix != 10) {
            t = t.substring(2, t.length);
            // A prefix with no number following isn't valid.
            if(t.length === 0) {
                wiz.compile.error(wiz.parse.getVerboseTokenName(numberToken, numberText) + " is not a valid integer literal", location);
                return null;
            }
        }
        var value = parseInt(t, radix);

        if(value > 0xFFFF || value < 0) {
            wiz.compile.error(wiz.parse.getVerboseTokenName(numberToken, numberText) + " is outside of permitted range 0..65535.", location);
            return null;
        }
        return wiz.ast.Number(numberToken, value, location);
    };

    that.parseAttribute = function() {
        var location = that.scanner.getLocation();
        var pieces = [];
        if(that.checkIdentifier()) {
            pieces.push(that.text);
        }
        that.nextToken(); // IDENTIFIER
        
        // Check if we should match ('.' IDENTIFIER)*
        while(that.token == wiz.parse.Token.Dot) {
            that.nextToken(); // .
            if(that.token == wiz.parse.Token.Identifier) {
                if(that.checkIdentifier()) {
                    pieces.push(that.text);
                }
                that.nextToken(); // IDENTIFIER
            } else {
                that.reject(that.token, that.text, "identifier after '.' in term");
                break;
            }
        }

        return wiz.ast.Attribute(pieces, location);
    };

    return that;
};

})(this);
(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.parse = typeof(wiz.parse) !== 'undefined' ? wiz.parse : {};

    var st = 0;
    var State = {
        Start: 'st' + (st++),
        String: 'st' + (st++),
        StringEscape: 'st' + (st++),
        LeadingZero: 'st' + (st++),
        IntDigits: 'st' + (st++),
        HexDigits: 'st' + (st++),
        BinDigits: 'st' + (st++),
        Identifier: 'st' + (st++),
        Slash: 'st' + (st++),
        SlashSlashComment: 'st' + (st++),
        SlashStarComment: 'st' + (st++),
        SlashStarCommentStar: 'st' + (st++),
        Tilde: 'st' + (st++),
        Plus: 'st' + (st++),
        Minus: 'st' + (st++),
        Equals: 'st' + (st++),
        Less: 'st' + (st++),
        LessLess: 'st' + (st++),
        LessLessLess: 'st' + (st++),
        Greater: 'st' + (st++),
        GreaterGreater: 'st' + (st++),
        GreaterGreaterGreater: 'st' + (st++),
    };

    wiz.parse.Scanner = function(file, filename) {
        var Token = wiz.parse.Token;

        var that = {};
        that.terminator = '';
        that.position = 0;
        that.commentLine = 0;
        that.buffer = '';
        that.text = '';
        that.lastText = '';
        that.state = State.Start;
        that.source = file.readLines();
        that.sourceIndex = 0;
        that.location = wiz.compile.Location(filename);
        
        that.consumeLastText = function() {
            var lastText = that.lastText;
            that.lastText = "";
            return lastText;
        };
        
        that.getLocation = function() {
            return that.location.copy();
        };
     
        function flushText() {
            that.state = State.Start;
            that.lastText = that.text;
            that.text = "";
        }

        function error(message) {
            wiz.compile.error(message, that.location);
        }

        that.next = function() {
            while(true) {
                while(that.position < that.buffer.length) {
                    var c = that.buffer.charAt(that.position);
                    switch(that.state) {
                        case State.Start:
                            switch(c) {
                                case '0':
                                    that.state = State.LeadingZero;
                                    that.text += c;
                                    break;
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                    that.state = State.IntDigits;
                                    that.text += c;
                                    break;
                                case '_':
                                case 'a':
                                case 'b':
                                case 'c':
                                case 'd':
                                case 'e':
                                case 'f':
                                case 'g':
                                case 'h':
                                case 'i':
                                case 'j':
                                case 'k':
                                case 'l':
                                case 'm':
                                case 'n':
                                case 'o':
                                case 'p':
                                case 'q':
                                case 'r':
                                case 's':
                                case 't':
                                case 'u':
                                case 'v':
                                case 'w':
                                case 'x':
                                case 'y':
                                case 'z':
                                case 'A':
                                case 'B':
                                case 'C':
                                case 'D':
                                case 'E':
                                case 'F':
                                case 'G':
                                case 'H':
                                case 'I':
                                case 'J':
                                case 'K':
                                case 'L':
                                case 'M':
                                case 'N':
                                case 'O':
                                case 'P':
                                case 'Q':
                                case 'R':
                                case 'S':
                                case 'T':
                                case 'U':
                                case 'V':
                                case 'W':
                                case 'X':
                                case 'Y':
                                case 'Z':
                                    that.state = State.Identifier;
                                    that.text += c;
                                    break;
                                case '\'': case '\"':
                                    that.terminator = c;
                                    that.state = State.String;
                                    break;
                                case ' ': case '\t': case '\r': case '\n': break;
                                case ':': that.position++; return Token.Colon;
                                case ',': that.position++; return Token.Comma;
                                case '.': that.position++; return Token.Dot;
                                case '(': that.position++; return Token.LParen;
                                case ')': that.position++; return Token.RParen;
                                case '[': that.position++; return Token.LBracket;
                                case ']': that.position++; return Token.RBracket;
                                case '{': that.position++; return Token.LBrace;
                                case '}': that.position++; return Token.RBrace;
                                case ';': that.position++; return Token.Semi;
                                case '#': that.position++; return Token.Hash;
                                case '|': that.position++; return Token.Or;
                                case '*': that.position++; return Token.Mul;
                                case '%': that.position++; return Token.Mod;
                                case '@': that.position++; return Token.At;
                                case '&': that.position++; return Token.And;
                                case '^': that.position++; return Token.Xor;
                                case '!': that.position++; return Token.Exclaim;
                                case '~': that.state = State.Tilde; break;
                                case '+': that.state = State.Plus; break;
                                case '-': that.state = State.Minus; break;
                                case '/': that.state = State.Slash; break;
                                case '=': that.state = State.Equals; break;
                                case '<': that.state = State.Less; break;
                                case '>': that.state = State.Greater; break;
                                default: error("unrecognized character " + c + " found.");
                            }
                            break;
                        case State.Identifier:
                            switch(c) {
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                case 'a':
                                case 'b':
                                case 'c':
                                case 'd':
                                case 'e':
                                case 'f':
                                case 'g':
                                case 'h':
                                case 'i':
                                case 'j':
                                case 'k':
                                case 'l':
                                case 'm':
                                case 'n':
                                case 'o':
                                case 'p':
                                case 'q':
                                case 'r':
                                case 's':
                                case 't':
                                case 'u':
                                case 'v':
                                case 'w':
                                case 'x':
                                case 'y':
                                case 'z':
                                case 'A':
                                case 'B':
                                case 'C':
                                case 'D':
                                case 'E':
                                case 'F':
                                case 'G':
                                case 'H':
                                case 'I':
                                case 'J':
                                case 'K':
                                case 'L':
                                case 'M':
                                case 'N':
                                case 'O':
                                case 'P':
                                case 'Q':
                                case 'R':
                                case 'S':
                                case 'T':
                                case 'U':
                                case 'V':
                                case 'W':
                                case 'X':
                                case 'Y':
                                case 'Z':
                                case '_':
                                    that.text += c;
                                    break;
                                default:
                                    flushText();
                                    return Token.Identifier;
                            }
                            break;
                        case State.String:
                            if(c == that.terminator) {
                                that.position++;
                                flushText();
                                return Token.String;
                            } else switch(c) {
                                case '\\':
                                    that.state = State.StringEscape;
                                    break;
                                default:
                                    that.text += c;
                                    break;
                            }
                            break;
                        case State.StringEscape:
                            that.state = State.String;
                            switch(c) {
                                case '\"': case '\'': case '\\':
                                    that.text += c;
                                    break;
                                case 't': that.text += '\t'; break;
                                case 'r': that.text += '\r'; break;
                                case 'n': that.text += '\n'; break;
                                case 'f': that.text += '\f'; break;
                                case 'b': that.text += '\b'; break;
                                case 'a': that.text += String.fromCharCode(0x07); break;
                                case '0': that.text += '\0'; break;
                                default:
                                    error("invalid escape sequence \\" + c + " in string literal");
                                    break;
                            }
                            break;
                        case State.LeadingZero:
                            switch(c) {
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                    that.state = State.IntDigits;
                                    that.text += c;
                                    break;
                                case 'x': that.state = State.HexDigits; that.text += c; break;
                                case 'b': that.state = State.BinDigits; that.text += c; break;
                                default:
                                    flushText();
                                    return Token.Integer;
                            }
                            break;
                        case State.IntDigits:
                            switch(c) {
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                    that.text += c;
                                    break;
                                default:
                                    flushText();
                                    return Token.Integer;
                            }
                            break;
                        case State.HexDigits:
                            switch(c) {
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                case 'a':
                                case 'b':
                                case 'c':
                                case 'd':
                                case 'e':
                                case 'f':
                                case 'A':
                                case 'B':
                                case 'C':
                                case 'D':
                                case 'E':
                                case 'F':
                                    that.text += c;
                                    break;
                                default:
                                    flushText();
                                    return Token.Hexadecimal;
                            }
                            break;
                        case State.BinDigits:
                            switch(c) {
                                case '0': case '1':
                                    that.text += c;
                                    break;
                                default:
                                    flushText();
                                    return Token.Binary;
                            }
                            break;
                        case State.Tilde:
                            that.state = State.Start;
                            switch(c) {
                                case '=': that.position++; return Token.NotEqual;
                                default: return Token.Not;
                            }
                            break;
                        case State.Plus:
                            that.state = State.Start;
                            switch(c) {
                                case '#': that.position++; return Token.AddC;
                                case '+': that.position++; return Token.Inc;
                                default: return Token.Add;
                            }
                            break;
                        case State.Minus:
                            that.state = State.Start;
                            switch(c) {
                                case '#': that.position++; return Token.SubC;
                                case '-': that.position++; return Token.Dec;
                                default: return Token.Sub;
                            }
                            break;
                        case State.Slash:
                            that.state = State.Start;
                            switch(c) {
                                case '/':
                                    that.state = State.SlashSlashComment;
                                    break;
                                case '*':
                                    that.state = State.SlashStarComment;
                                    that.commentLine = that.location.line;
                                    break;
                                default:
                                    return Token.Div;
                            }
                            break;
                        case State.SlashSlashComment: break;
                        case State.SlashStarComment:
                            switch(c) {
                                case '*': that.state = State.SlashStarCommentStar; break;
                                default: break;
                            }
                            break;
                        case State.SlashStarCommentStar:
                            switch(c) {
                                case '/': that.state = State.Start; break;
                                default: that.state = State.SlashStarComment; break;
                            }
                            break;
                        case State.Equals:
                            that.state = State.Start;
                            switch(c) {
                                case '=': that.position++; return Token.Equal;
                                default: return Token.Set;
                            }
                            break;
                        case State.Less:
                            that.state = State.Start;
                            switch(c) {
                                case '<': that.state = State.LessLess; break;
                                case '>': that.position++; return Token.Swap;
                                case '=': that.position++; return Token.LessEqual;
                                default: return Token.Less;
                            }
                            break;
                        case State.LessLess:
                            that.state = State.Start;
                            switch(c) {
                                case '<': that.state = State.LessLessLess; break;
                                case '-': that.position++; return Token.ArithShiftL;
                                default: return Token.ShiftL;
                            }
                            break;
                        case State.LessLessLess:
                            that.state = State.Start;
                            switch(c) {
                                case '#': that.position++; return Token.RotateLC;
                                default: return Token.RotateL;
                            }
                            break;
                        case State.Greater:
                            that.state = State.Start;
                            switch(c) {
                                case '>': that.state = State.GreaterGreater; break;
                                case '<': that.position++; return Token.Swap;
                                case '=': that.position++; return Token.GreaterEqual;
                                default: return Token.Greater;
                            }
                            break;
                        case State.GreaterGreater:
                            that.state = State.Start;
                            switch(c) {
                                case '>': that.state = State.GreaterGreaterGreater; break;
                                case '-': that.position++; return Token.ArithShiftR;
                                default: return Token.ShiftR;
                            }
                            break;
                        case State.GreaterGreaterGreater:
                            that.state = State.Start;
                            switch(c) {
                                case '#': that.position++; return Token.RotateRC;
                                default: return Token.RotateR;
                            }
                            break;
                        default:
                            throw new Error('unhandled that.state ' + that.state);
                    }
                    that.position++;
                }
                
                if(that.sourceIndex < that.source.length) {
                    that.buffer = that.source[that.sourceIndex++];

                    // Special handling in that.states for end-of-line.
                    switch(that.state)
                    {
                        case State.SlashSlashComment:
                            that.state = State.Start;
                            break;
                        case State.String:
                            that.state = State.Start;
                            error("expected closing quote " + that.terminator + ", but got end-of-line");
                            break;
                        case State.StringEscape:
                            that.state = State.Start;
                            error("expected string escape sequence, but got end-of-line");
                            break;
                        default:
                            break;
                    }
                    that.position = 0;
                    that.location.line++;
                } else {
                    // End-of-file.
                    switch(that.state) {
                        case State.Identifier:
                            flushText();
                            return Token.Identifier;
                        case State.LeadingZero:
                        case State.IntDigits:
                            flushText();
                            return Token.Integer;
                        case State.HexDigits:
                            flushText();
                            return Token.Hexadecimal;
                        case State.BinDigits:
                            flushText();
                            return Token.Binary;
                        case State.String:
                            that.state = State.Start;
                            error("expected closing quote " + that.terminator + ", but got end-of-file");
                            break;
                        case State.StringEscape:
                            that.state = State.Start;
                            error("expected string escape sequence, but got end-of-file");
                            break;
                        case State.SlashStarComment:
                            error("expected */ to close /* comment starting on line " + that.commentLine + ", but got end-of-file");
                            break;
                        default:
                            break;
                    }
                    return Token.EndOfFile;
                }
            }
            throw new Error();
        };

        return that;
    };    
})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.parse = typeof(wiz.parse) !== 'undefined' ? wiz.parse : {};

    var tk = 0;
    var Token = wiz.parse.Token =  {
        None: '$tk' + (tk++),
        EndOfFile: '$tk' + (tk++),
        InvalidChar: '$tk' + (tk++),
        // Identifier. Keywords are also identifiers, but have reserved meaning determined later.
        Identifier: '$tk' + (tk++),
        // Numeric constants.
        Integer: '$tk' + (tk++),
        Hexadecimal: '$tk' + (tk++),
        Binary: '$tk' + (tk++),
        // String literal.
        String: '$tk' + (tk++),
        // Punctuation
        Colon: '$tk' + (tk++),
        Comma: '$tk' + (tk++),
        Dot: '$tk' + (tk++),
        LParen: '$tk' + (tk++),
        RParen: '$tk' + (tk++),
        LBracket: '$tk' + (tk++),
        RBracket: '$tk' + (tk++),
        LBrace: '$tk' + (tk++),
        RBrace: '$tk' + (tk++),
        Semi: '$tk' + (tk++),
        Exclaim: '$tk' + (tk++),
        Hash: '$tk' + (tk++),
        // Operator symbols.
        Add: '$tk' + (tk++),
        AddC: '$tk' + (tk++),
        Inc: '$tk' + (tk++),
        Sub: '$tk' + (tk++),
        SubC: '$tk' + (tk++),
        Dec: '$tk' + (tk++),
        Mul: '$tk' + (tk++),
        Div: '$tk' + (tk++),
        Mod: '$tk' + (tk++),
        At: '$tk' + (tk++),
        Set: '$tk' + (tk++),
        Less: '$tk' + (tk++),
        Greater: '$tk' + (tk++),
        LessEqual: '$tk' + (tk++),
        GreaterEqual: '$tk' + (tk++),
        NotEqual: '$tk' + (tk++),
        Equal: '$tk' + (tk++),
        Swap: '$tk' + (tk++),
        ShiftL: '$tk' + (tk++),
        ShiftR: '$tk' + (tk++),
        Not: '$tk' + (tk++),
        And: '$tk' + (tk++),
        Xor: '$tk' + (tk++),
        Or: '$tk' + (tk++),
        ArithShiftL: '$tk' + (tk++),
        ArithShiftR: '$tk' + (tk++),
        RotateL: '$tk' + (tk++),
        RotateR: '$tk' + (tk++),
        RotateLC: '$tk' + (tk++),
        RotateRC: '$tk' + (tk++),
    };
    for(var k in Token) {
        Token[Token[k]] = Token[k];
    }

    var tokenNames = {
        None: "(???)",
        EndOfFile: "end-of-file",
        InvalidChar: "invalid character",
        // Identifier. Keywords are also identifiers, but have reserved meaning determined later.
        Identifier: "identifier",
        // Numeric constants.// Numeric constants.
        Integer: "integer constant",
        Hexadecimal: "hexadecimal constant",
        Binary: "binary constant",
        // String literal.// String literal.
        String: "string literal",
        // Punctuation// Punctuation
        Colon: "':'",
        Comma: "','",
        Dot: "'.'",
        LParen: "'('",
        RParen: "')'",
        LBracket: "'['",
        RBracket: "']'",
        LBrace: "'{'",
        RBrace: "'}'",
        Semi: "';'",
        Exclaim: "'!'",
        Hash: "'#'",
        // Operator symbols.// Operator symbols.
        Add: "'+'",
        AddC: "'+#'",
        Inc: "'++'",
        Sub: "'-'",
        SubC: "'-#'",
        Dec: "'--'",
        Mul: "'*'",
        Div: "'/'",
        Mod: "'%'",
        At: "'@'",
        Set: "'='",
        Less: "'<'",
        Greater: "'>'",
        LessEqual: "'<='",
        GreaterEqual: "'>='",
        NotEqual: "'~='",
        Equal: "'=='",
        Swap: "'<>'",
        ShiftL: "'<<'",
        ShiftR: "'>>'",
        Not: "'~'",
        And: "'&'",
        Xor: "'^'",
        Or: "'|'",
        ArithShiftL: "'<<-'",
        ArithShiftR: "'>>-'",
        RotateL: "'<<<'",
        RotateR: "'>>>'",
        RotateLC: "'<<<#'",
        RotateRC: "'>>>#'",
    };
    for(var k in tokenNames) {
        tokenNames[Token[k]] = tokenNames[k];
    }

    var Branch = wiz.parse.Branch = {
        Less: Token.Less,
        Greater: Token.Greater,
        LessEqual: Token.LessEqual,
        GreaterEqual: Token.GreaterEqual,
        NotEqual: Token.NotEqual,
        Equal: Token.Equal,
    };
    for(var k in Branch) {
        Branch[Branch[k]] = Branch[k];
    }

    var Prefix = wiz.parse.Prefix = {
        Not: Token.Not,
        Sub: Token.Sub,
        Low: Token.Less,
        High: Token.Greater,
        Swap: Token.Swap,
        Grouping: Token.LParen,
        Indirection: Token.LBracket,
    };
    for(var k in Prefix) {
        Prefix[Prefix[k]] = Prefix[k];
    }

    var Postfix = wiz.parse.Postfix = {
        Inc: Token.Inc,
        Dec: Token.Dec,
    };
    for(var k in Postfix) {
        Postfix[Postfix[k]] = Postfix[k];
    }

    var Infix = wiz.parse.Infix = {
        At: Token.At,
        Add: Token.Add,
        Sub: Token.Sub,
        Mul: Token.Mul,
        Div: Token.Div,
        Mod: Token.Mod,
        AddC: Token.AddC,
        SubC: Token.SubC,
        ShiftL: Token.ShiftL,
        ShiftR: Token.ShiftR,
        RotateL: Token.RotateL,
        RotateR: Token.RotateR,
        RotateLC: Token.RotateLC,
        RotateRC: Token.RotateRC,
        ArithShiftL: Token.ArithShiftL,
        ArithShiftR: Token.ArithShiftR,
        Or: Token.Or,
        And: Token.And,
        Xor: Token.Xor,
        Colon: Token.Colon,
    };
    for(var k in Infix) {
        Infix[Infix[k]] = Infix[k];
    }

    var kw = 0;
    var Keyword = wiz.parse.Keyword = {
        None: '$kw' + (kw++),
        Def: '$kw' + (kw++),
        Let: '$kw' + (kw++),
        Var: '$kw' + (kw++),
        Goto: '$kw' + (kw++),
        When: '$kw' + (kw++),
        Call: '$kw' + (kw++),
        Return: '$kw' + (kw++),
        Resume: '$kw' + (kw++),
        Sleep: '$kw' + (kw++),
        Suspend: '$kw' + (kw++),
        Nop: '$kw' + (kw++),
        Bank: '$kw' + (kw++),
        In: '$kw' + (kw++),
        Byte: '$kw' + (kw++),
        Word: '$kw' + (kw++),
        Package: '$kw' + (kw++),
        End: '$kw' + (kw++),
        Include: '$kw' + (kw++),
        Embed: '$kw' + (kw++),
        Enum: '$kw' + (kw++),
        If: '$kw' + (kw++),
        Then: '$kw' + (kw++),
        Else: '$kw' + (kw++),
        ElseIf: '$kw' + (kw++),
        While: '$kw' + (kw++),
        Do: '$kw' + (kw++),
        Loop: '$kw' + (kw++),
        Until: '$kw' + (kw++),
        And: '$kw' + (kw++),
        Or: '$kw' + (kw++),
        Compare: '$kw' + (kw++),
        To: '$kw' + (kw++),
        Push: '$kw' + (kw++),
        Pop: '$kw' + (kw++),
        Via: '$kw' + (kw++),
        Break: '$kw' + (kw++),
        Continue: '$kw' + (kw++),
        Abort: '$kw' + (kw++),
        Inline: '$kw' + (kw++),
        Unroll: '$kw' + (kw++),
        Is: '$kw' + (kw++),
        Func: '$kw' + (kw++),
        Task: '$kw' + (kw++),
    };
    for(var k in Keyword) {
        Keyword[Keyword[k]] = Keyword[k];
    }

    var keywords = {
        "def": Keyword.Def,
        "let": Keyword.Let,
        "var": Keyword.Var,
        "goto": Keyword.Goto,
        "when": Keyword.When,
        "call": Keyword.Call,
        "return": Keyword.Return,
        "resume": Keyword.Resume,
        "sleep": Keyword.Sleep,
        "suspend": Keyword.Suspend,
        "nop": Keyword.Nop,
        "bank": Keyword.Bank,
        "in": Keyword.In,
        "byte": Keyword.Byte,
        "word": Keyword.Word,
        "package": Keyword.Package,
        "end": Keyword.End,
        "include": Keyword.Include,
        "embed": Keyword.Embed,
        "enum": Keyword.Enum,
        "if": Keyword.If,
        "then": Keyword.Then,
        "else": Keyword.Else,
        "elseif": Keyword.ElseIf,
        "while": Keyword.While,
        "do": Keyword.Do,
        "loop": Keyword.Loop,
        "until": Keyword.Until,
        "and": Keyword.And,
        "or": Keyword.Or,
        "compare": Keyword.Compare,
        "to": Keyword.To,
        "push": Keyword.Push,
        "pop": Keyword.Pop,
        "via": Keyword.Via,
        "break": Keyword.Break,
        "continue": Keyword.Continue,
        "abort": Keyword.Abort,
        "inline": Keyword.Inline,
        "unroll": Keyword.Unroll,
        "is": Keyword.Is,
        "func": Keyword.Func,
        "task": Keyword.Task,
    };
        
    var keywordNames = {};
    for(var name in keywords) {
        if(keywords.hasOwnProperty(name)) {
            keywordNames[keywords[name]] = name;
        }
    }

    wiz.parse.getSimpleTokenName = function(token) {
        return tokenNames[token];
    };

    wiz.parse.getVerboseTokenName = function(token, text) {
        if(token == Token.String)
        {
            text = "\"" + text + "\"";
        }
        if(text.length > 32)
        {
            text = text.substring(0, 29) + "...";
        }
        switch(token)
        {
            case Token.Identifier:
                var keyword = wiz.parse.findKeyword(text);
                if(keyword == Keyword.None)
                {
                    return "identifier '" + text + "'";
                }
                return "keyword '" + text + "'";
            case Token.Integer:
            case Token.Hexadecimal:
            case Token.Binary:
                return "number '" + text + "'";
            case Token.String:
                return "string " + text + "";
            default:
                return wiz.parse.getSimpleTokenName(token);
        }
    };

    wiz.parse.getKeywordName = function(keyword) {
        return keywordNames[keyword];
    };

    wiz.parse.findKeyword = function(text) {
        return keywords[text] || Keyword.None;
    };

})(this);(function(globals) {
    'use strict';
    var wiz = globals.wiz = typeof(globals.wiz) !== 'undefined' ? globals.wiz : {};
    wiz.sym = typeof(wiz.sym) !== 'undefined' ? wiz.compile : {};

    wiz.sym.check = function(definitionType, def) {
        if(typeof(def) === 'object' && def && def.definitionType == definitionType) {
            return def;
        }
        return null;
    }

    wiz.sym.Definition = function(decl) {
        var that = {};
        that.definitionType = 'Definition';
        that.decl = decl;
        return that;
    };

    wiz.sym.AliasDef = function(decl, definition) {
        var that = wiz.sym.Definition(decl);
        that.definitionType = 'AliasDef';
        that.definition = definition;
        return that;
    }

    wiz.sym.BankDef = function(decl, bank) {
        var that = wiz.sym.Definition(decl);
        that.definitionType = 'BankDef';
        that.bank = bank;
        return that;
    }

    wiz.sym.ConstDef = function(decl, environment) {
        var that = wiz.sym.Definition(decl);
        that.definitionType = 'ConstDef';
        that.environment = environment;
        return that;
    }

    wiz.sym.FuncDef = function(decl) {
        var that = wiz.sym.Definition(decl);
        that.definitionType = 'FuncDef';
        return that;
    }

    wiz.sym.LabelDef = function(decl) {
        var that = wiz.sym.Definition(decl);
        that.definitionType = 'LabelDef';
        that.hasAddress = false;
        that.address = 0;
        return that;
    }

    wiz.sym.PackageDef = function(decl, environment) {
        var that = wiz.sym.Definition(decl);
        that.definitionType = 'PackageDef';
        that.environment = environment;
        return that;
    }

    wiz.sym.VarDef = function(decl) {
        var that = wiz.sym.Definition(decl);
        that.definitionType = 'VarDef';
        that.hasAddress = false;
        that.address = 0;
        return that;
    }
})(this);